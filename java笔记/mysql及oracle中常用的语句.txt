
<=====================================================================================================================================================================>
连接mysql数据库的所需信息:

	Driver="com.mysql.jdbc.Driver";
	url="jdbc:mysql://localhost:3306/数据库名";
	username="root";
	password="****";


<=====================================================================================================================================================================>
解决Mysql中的编码问题:
	打开mysql安装文件 my.ini去修改里面的字符编码,一般改为utf8.

<=====================================================================================================================================================================>
mysql基本配置信息查询:

    status

<=====================================================================================================================================================================>

在cmd界面中启动mysql数据库:

	(当然这里要先转到相应的跟目录上)  mysql -u用户名 -p密码

<=====================================================================================================================================================================>
MySQL-5.5.22绿色版安装说明及mysql的一些常用的命令:

	1、把mysql-5.5.22.rar解压到C盘根目录，如果要解压到其它目录则需要修改
	   C:\mysql-5.5.22\my.ini中的
		basedir="c:/mysql-5.5.22/"
		datadir="c:/mysql-5.5.22/data/"
		为相应的路径。
		数据库实例的账号密码：root 888
		
	2、创建mysql5的服务：
		cd c:\mysql-5.5.22\bin\
		mysqld --install MySQL55 --defaults-file=c:\mysql-5.5.22\my.ini
		
		如果上面的不成功就是如下的命令:
		
		cd c:\mysql-5.5.22\bin\
		mysqld --install MySQL55
		
		2.2:删除mysql5的服务:
		
		cd c:\mysql-5.5.22\bin\
		mysqld --remove mysql55
		

	3、创建数据库：
		mysql -uroot -p888
		CREATE DATABASE `oplife` CHARACTER SET 'utf8' COLLATE 'utf8_bin';

	4、其它命令说明
		--导出服务器上数据库的备份文件
		mysqldump -uroot -p888 -R oplife -r d:\oplife.sql

		--导入数据库备份文件
		mysql -uroot -p888 oplife < d:\oplife.sql

	5、启动
		命令行：net start MySQL55
	6、关闭
		命令行：net stop MySQL55
	7、删除服务
		命令行：
		cd c:\mysql-5.5.22\bin\
		mysqld --remove MySQL55

<=====================================================================================================================================================================>
MYSQL 连接数据库命令收藏
	一、MySQL 连接本地数据库，用户名为“root”，密码“123”（注意：“-p”和“123” 之间不能有空格）

	C:\>mysql -h localhost -u root -p123
	二、MySQL 连接远程数据库（192.168.0.201），端口“3306”，用户名为“root”，密码“123”

	C:\>mysql -h 172.16.16.45 -P 3306 -u root -p123
	三、MySQL 连接本地数据库，用户名为“root”，隐藏密码

	C:\>mysql -h localhost -u root -p

	Enter password:
	四、MySQL 连接本地数据库，用户名为“root”，指定所连接的数据库为“test”

	C:\>mysql -h localhost -u root -p123 -D test

<=====================================================================================================================================================================>
mysql 使用 mysqldump/mysql 命令导出导入一个用户下一个库的数据

	1.导出:
		mysqldump -u root -p platform_cas > D:\platform.sql
		
		备注: root 是用户名 , platform_cas 是数据库名 , D:\platform.sql 导出的文件
		
	2.创建数据库:
		CREATE DATABASE jilin_platform CHARACTER SET 'utf8'
		
	3.导入:
		mysql -u root -p imp_platform_cas < D:\platform_cas.sql

		备注: root 是用户名 , platform_cas 是数据库名 , D:\platform.sql 导出的文件

	4.执行导出/导入命令后会让你输入密码,输入即可

<=====================================================================================================================================================================>
注意:如果直接在cmd界面中使用insert into语句,其中values()中除了数值型数据不加 '' 号外,其余的都要加,当然,where 语句后面的条件判断语句也是一样的; 

例如:

 delete from customer where username='吴林';

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

create table user(id int,name varchar(20),password varchar(6),birthday date);
insert into user(id,name,password,birthday) values(1,'jack','000000','2014-01-06');

<--------------------------------------------------------------------------------------------------------------------------------------------------------------------->

mysql中没有to_date();这种语法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

select ip,max(votetime) as votetime from info where ip = '166.888.888.666' group by ip  //ip的类型是varchar型

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于mysql数据库与oracle数据库的日期类型:

	mysql中timestamp类型对应oracle数据库中的date类型

<=====================================================================================================================================================================>
使用数据库语句：
use mydb2;

<=====================================================================================================================================================================>

创建表语句:

如果该表存在就删除整张表
drop table if exists customerRoom;
如果该表不存在就创建一张表
create table if not exists customerRoom(
	id int primary key auto_increment,    //将该id号设为主键且该id号自动增长
	storeyNumber int,
	roomNumber int,
	realRoomNumber varchar(12),
	perStoreyNumber int,
	flag int
);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

create table if not exists customer(
	vid int,
	username varchar(20),
	gender varchar(4),
	identityCardNumber varchar(25),
	room varchar(12),
	startTime timestamp,
	constraint vid_FK foreign key(vid) references customerRoom(id) on delete cascade //这里的vid号是引用表customerRoom中id号的外键
);
    以上两张表中:customerRoom是主表,而customer是从表,创建时要先创建主表,再创建从表,删除时要先删除从表,再在删除主表

	//当同时有两张表的外键引用同一张表的唯一主键时,这两张表的vid_FK 必须不一样,

<=====================================================================================================================================================================>

删除表中行语句:

delete from customerRoom where id=4;
 delete from customer where username='吴林';

<=====================================================================================================================================================================>

更新表中某一行的语句:

update customerRoom set flag=1 where id=1;
update vote set ticket = ticket + 1 where id = ?

<=====================================================================================================================================================================>
mysql 修改字段长度

	alter table news  modify column title varchar(130);
	alter table 表名 modify column 字段名 类型;

	如：news 表里的title  字段 原来长度是 100个字符，现长度要改成130个字符
	alter table news modify column title varchar(130);

<=====================================================================================================================================================================>

查询语句:

select ip,max(votetime) as votetime from info where ip = ? group by ip
select realRoomNumber,max(roomNumber) as 最大数 from customerRoom group by flag;//通过flag进行分组，并且找出每一组roomNumber列的最大数
select flag ,realRoomNumber from customerRoom where flag=0
select count(*) from customerRoom;  //计算出该表一共有多少行
select sum(roomNumber) from customerRoom;  //计算出roomNumber这一列的总数

select * from customerRoom where flag=0 and storeyNumber=1;

select * from vote order by ticket desc;   //以ticket为标准按降序排列

<=====================================================================================================================================================================>

插入语句：

insert into customerRoom(storeyNumber,roomNumber,realRoomNumber,perStoreyNumber,flag) values(?,?,?,?,?);
insert into books(name,birthday,detailed) values('吴林','2000-12-21','好书');

<=====================================================================================================================================================================>
mysql中如何插入和查询bit数据

select bin(accountExpired),bin(accountLocked),bin(credentialsExpired) from sys_user;

update sys_user set accountExpired = b'0',accountLocked=b'0',credentialsExpired=b'0' where id = '1';
<=====================================================================================================================================================================>
Timestamp的使用范例:

对于java.sql.Timestamp 这个类型,再插入语句中,她跟自动增长的id号一样不需要在插入语句中写出来;

<=====================================================================================================================================================================>

创建数据库语句:
	create database oa_20140327 default character set utf8;

<=====================================================================================================================================================================>
关键字不能用来做别名,最好是不要用到关键字

<=====================================================================================================================================================================>
MySQL查看表相关外键关系sql(及通过主表查询有哪些字表关联该主表的外键关系)

	select
	TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME, REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME
	from INFORMATION_SCHEMA.KEY_COLUMN_USAGE
	where
	REFERENCED_TABLE_NAME = '<table>';
	
<=====================================================================================================================================================================>
MYSQL数据库中的现有表增加新字段（列）
	ALTER TABLE `数据库名`.`表名` ADD COLUMN 字段名称 VARCHAR(6) DEFAULT '默认值'; 


<=====================================================================================================================================================================>
MySQL查看表结构SQL语句
 
	 mysql查看表结构命令，如下:

	desc 表名;
	show columns from 表名;
	describe 表名;
	show create table 表名;

	use information_schema; #切换到information_schema数据库
	select * from columns where table_name='表名'; #查看表信息

	顺便提下MySQL常用语句：
	show databases;
	use 数据库名;
	show tables;
	 
	另外Oracle几个有用的语句：
	select * from v$database;
	select * from all_users;
	select * from user_tables;

<=====================================================================================================================================================================>























<=====================================================================================================================================================================>
<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

oracle的连接信息:
	Driver="oracle.jdbc.driver.OracleDriver";
	URL="jdbc:oracle:thin:@localhost:1521:orcl";
	userName="scott";
	password="tiger";

<=====================================================================================================================================================================>
oracle中常用的语句:					sql:结构化查询语言(structure query language)        pl: 过程话语言(process language)	

	第一次用oracle的步骤:
		
		1.打开cmd界面
		2.输入sqlplus/nolog
		3.输入conn/as sysdba   //最高用户权限
		4.alter user scott identified by tiger account unlock;

	第二次使用oracle的步骤:

		1.打开cmd界面
		2.输入sqlplus/nolog
		3.conn scott/tiger


		第一个用户的用户名与密码:scott , tiger  
		第一个用户的用户名与密码:hr  , hr

<=====================================================================================================================================================================>
oracle有多个实例sid时如何启动指定的sid的oracle数据库(这是在windows上)

	步骤:   (注意: {C:> 表示cmd窗口的跟路径,})
		
		1.  C:> net stop ORACLEServiceORCL   -- 停止服务
		
		2.  C:> net stop ORACLEServicemyOrcl  --停止服务  //注意:这里的1和2是同一操作,只是为了停止所有oracle服务
		
		3.  C:> net start ORACLEServiceORCL   -- 启动服务
		
		4.  C:> set ORACLE_SID=ORCL  -- 设置要启动的数据库实例sid
		
		5.  C:> sqlplus /nolog
		
		6.  sql:> conn sys/change_on_install as sysdba
		
		7.  sql:> startup
		

<=====================================================================================================================================================================>
oracle如何连接指定sid的数据库

	一般可以使用这种方式指定连接本地或者远程数据库：
	sqlplus 用户名/密码@主机名(IP也行):1521/数据库名 as 角色;比如我给你示范下：sqlplus sys/sys@PC20110860823lzk:1521/orcl as sysdba;
	
<=====================================================================================================================================================================>
怎样查看Oracle的数据库名称sid

	怎样查看Oracle的数据库名称sid
	用sysdba身份登录 比如 conn / as  sysdba 匿名管理员登陆
	执行 select name form V$database; 或是执行select * from  V$database;
	不过执行第二个显示的内容太多了不好找自己想要的结果
	你也可以先用desc V$database;语句查看一下V$database都有什么字段然后选择自己想要的字段进行选择
	查看实例名称(sid)：
	select instance_name from  V$instance;
	一般默认情况下sid与你的数据库的名称是一样的！
	
<=====================================================================================================================================================================>
Oracle忘记密码如何重置

	alter user scott identified by password;
	
<=====================================================================================================================================================================>

三大范式:
	1.表中列不可用在分
	2.在满足第一范式的基础上,非主键列必须依赖主键列
	3.在满足第二范式的基础上,非主键列必须相互独立


<=====================================================================================================================================================================>
oracle中常用的查询语句:        

		一张表的行是记录,列是字段    
		
		
<=====================================================================================================================================================================>
另外Oracle几个有用的语句：
	select * from v$database;
	select * from all_users;
	select * from user_tables;

<=====================================================================================================================================================================>
--查找外键
--select * from user_constraints where constraint_name like '%FK_392pik77wly6j7nat36b836gl%';
--select * from writ_reward  where zfbh ='5117150523'
<=====================================================================================================================================================================>
如何通过约束名查找对应所关联的表和列

	select constraint_name,column_name,table_name from user_cons_columns where constraint_name = 'FK_DEQSG2RPVQ17SRU9YW5651L6G';

	select constraint_name,column_name,table_name from user_cons_columns where table_name = 'CRIMINAL_BASE_INFO';

<=====================================================================================================================================================================>
 Oracle报错：“ORA-02292：违反完整约束条件（XXX.FKXXX）- 已找到子记录
 
 删除表A的记录时，Oracle 报错：“ORA-02292：违反完整约束条件（XXX.FKXXX）- 已找到子记录

	1、找到以”FKXXX“为外键的表A的子表，直接运行
	select a.constraint_name, a.table_name, b.constraint_name 
	from user_constraints a, user_constraints b
	where a.constraint_type = 'R' 
	and b.constraint_type = 'P' 
	and a.r_constraint_name = b.constraint_name
	and a.constraint_name = 'FKXXX'

	2、删除相应的子表记录

	3、删除主表记录

		
<=====================================================================================================================================================================>
oracle 查询主表的主键被其他表作为外键参照的SQL

	1,查询主表的主键被其他表作为外键参照的SQL
	
		select child_cons.constraint_name,

		child_cons.table_name child_table_name,

		parent_cons.table_name parent_table,

		child_cons.status

		from (select *

		from all_constraints

		where owner = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')

		and table_name = '&parent_tab') parent_cons,

		(select *

		from all_constraints

		where owner = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')

		and constraint_type = 'R') child_cons

		where parent_cons.constraint_name = child_cons.r_constraint_name;

	2. Disable 其他表的外键约束(禁用约束)
	
		select 'alter table ' || child_cons.table_name || ' disable constraint ' ||

		child_cons.constraint_name || ';'

		from (select *

		from all_constraints

		where owner = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')

		and table_name = '&parent_tab') parent_cons,

		(select *

		from all_constraints

		where owner = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')

		and constraint_type = 'R') child_cons

		where parent_cons.constraint_name = child_cons.r_constraint_name;
		
	2. enable 其他表的外键约束
	
		select 'alter table ' || child_cons.table_name || ' enable constraint ' ||

		child_cons.constraint_name || ';'

		from (select *

		from all_constraints

		where owner = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')

		and table_name = '&parent_tab') parent_cons,

		(select *

		from all_constraints

		where owner = SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')

		and constraint_type = 'R') child_cons

		where parent_cons.constraint_name = child_cons.r_constraint_name;


<=====================================================================================================================================================================>
查询当前用户下的表
		
	select * from TAB

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------    	以下是用scott用户
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------                                                                                    

	SELECT:

		SELECT 12*sal+1000,empno as "编号",empno||comm as "奖金" FROM emp;   //  这个" || " 是连接符的意思
	
		SELECT e.empno,e.sal,'薪水'||sal FROM emp e;

		SELECT distinct job FROM emp;   //解决某一列的重复行

		DESCRIBE emp; 或 desc emp;  //查询表结构   //这条语句如果是在PL/SQL Developer工具中只能在Command window窗口中应用,而不能在SQL window 中使用

		SELECT * FROM emp WHERE sal>2000 AND job='MANAGER';

		SELECT * FROM emp WHERE sal BETWEEN 2000 AND 4000;   //BETWEEN...AND...表示在...之间.且是闭区间

		SELECT * FROM EMP WHERE deptno IN(10,30);  //IN(x,y,...)表示的意思是x或y或...

		SELECT* FROM emp WHERE ename LIKE 'S%' OR ename LIKE '_M%';  //LIKE 'S%' :表示以S开头,%是通配符 ,而 _ 表示一个字符  //like的用法

		SELECT* FROM emp WHERE not ename LIKE 'S%' OR not ename LIKE '_M%';  //LIKE 'S%' :表示以S开头,%是通配符 ,而 _ 表示一个字符 //not like的用法

		SELECT * FROM WHERE ename LIKE 'S\_%' ESCAPE '\';    //表示'\' 通过ESCAPE 定义为转义符,因此'S\_%' 中的\_ 表示的就是下划线 " _ " .

		SELECT ename ,LOWER(ename) FROM dual;  //dual是一张'伪表'
		
		select to_char(sys_guid()||'') as id from dual; 解决jpa转换时会将其转换为char[]的问题(这是自定义的将sql查询出来的数据封装成对象)

		SELECT * FROM emp WHERE ename IS NOT NULL AND deptno NOT IN(10,20) AND comm IS NULL ;  //表示ename不为null且deptno不包含10和20且comm为null的
		
		select * from emp where not deptno=10;  //where NOT <条件> --不满足条件的

		SELECT SYSDATE FROM dual ; //取得当前时间

		SELECT ename ,(12*sal)+NVL(comm,0) FROM emp;  // NVL(comm,x);去null函数,当comm为null时用x替代; ;

		SELECT e.last_name,,d.department_name FROM employees e ,departments d WHERE e.department=d.department_id; //就是从表的外键必须等于主表的主键,

											//三张表,四张表,...都要遵循这个原理
	
		SELECT e.last_name,,d.department_name FROM employees e ,departments d WHERE e.department=d.department_id(+);  

		SELECT   e.employee_id,e.last_name,m.last_name FROM employees e ,employees m WHERE e.manager_id=m.employee_id  //把一张表看成两张表来进行等值关联
							//员工上级的id要等于员工的id

		SELECT department_id,department_name location_id ,city FROM departments d natural JOIN locations ;  //自然连接  (一般不用)

		SELECT * FROM emp WHERE empno=&ax   //ax要传的参数名称

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

sql的标准select语法:

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
表的关联: 等值关联,自关联,外连接(左外,右外,全外). 
               
 		SELECT department_id,department_name location_id ,city FROM departments d JOIN locations USING;

		SELECT * FROM departments d JOIN locations l ON d.location_id=l.location_id;  //与等值连接一样

		SELECT * FROM departments d JOIN locations l ON d.location_id=l.location_id WHERE d.department>60;  //与等值连接一样
		或
		SELECT * FROM departments d JOIN locations l ON d.location_id=l.location_id AND d.department>60;  //与等值连接一样

		SELECT * FROM departments d LEFT JOIN employees ON d.department_id=d.department_id  ;  //左链接

		SELECT * FROM departments d LEFT OUTER  JOIN employees ON d.department_id=d.department_id  ; //左外连接
   
		SELECT d.dname,avg(e.sal) from e

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------  对于左连接 (left join) 的理解:

	SELECT * FROM dept d left JOIN emp e ON d.deptno=e.deptno;

	上面语句的意思就是将dept 表中所有的记录都显示出来,如果emp中没有与之对应等值记录,则就用null与之对应,他与oracle的这条语句是等价的

	SELECT * FROM dept d ,emp e WHERE d.deptno=e.deptno(+);   

	解释  d.deptno=e.deptno(+) 这段语句: 这段语句表示将dept 表中所有的记录都显示出来, '+' 表示如果emp中没有与之对应等值记录,则就用null与之对应

...........................................................................
	
	右连接(right join)同理, 对于左外连接(left outer join) 与右外连接(right outer join )我的与左连接 (left join)和右连接(right join)同理;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何将例如A表(123456789)与B表(123)中A表不包含B的数据查询出来(利用left join 或者 right join),如下列(1)

	select --a.id,b.id 
	count(1)
	from (select id 
	--count(1)
	from criminal_base_info where zfztname = '在押' and isDelete = '0'
	and zyxzId in('code_zyxz_1','code_zyxz_2','code_zyxz_3','code_zyxz_4','code_zyxz_5','code_zyxz_6','code_zyxz_7','code_zyxz_15')

	) a left join (
	select --baseInfo.id
	count(1)
	from criminal_leave_hisArchive a 
	left join criminal_base_info baseInfo on a.criminalbaseinfoid=baseInfo.Id 
	where 1=1  and 
	(a.syrq<= TO_DATE('2017-08-04','yyyy-MM-dd') or a.syrq is null) 
	and (a.ljrq is null or a.ljrq > TO_DATE('2017-08-04','yyyy-MM-dd') )  
	) b on a.id = b.id where b.id is null and a.id is not null
	
.....................................................................................................................................................................
现有A,B,C三张表,A left join (B,C) 或者 A right join (B,C) 如上列(1) 都没有出现不包含的数据,而实际单独(B,C) 的数据却比A多,那说明(B,C) 中某些数据存在多条的情况,如下列


	select * from (
	select baseInfo.id
	,baseInfo.jymc,baseInfo.jybh,
	count(1) num
	from criminal_leave_hisArchive a 
	left join criminal_base_info baseInfo on a.criminalbaseinfoid=baseInfo.Id 
	where 1=1  and (a.syrq<= TO_DATE('2017-08-04','yyyy-MM-dd') or a.syrq is null) 
	and (a.ljrq is null or a.ljrq > TO_DATE('2017-08-04','yyyy-MM-dd') )  

	group by baseInfo.id
	,baseInfo.jymc,baseInfo.jybh
	) where num>1

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------    

 	以下是用hr用户
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

		SELECT last_name ,job_id,salary,                           //表示当job_id的值是'AD_ASST' 时,选择salary*1.5,当job_id的值是'MK_REP' 时,选择salary*1.2
			CASE job_id WHEN 'AD_ASST' THEN salary*1.5         //否则选择salary,
				    WHEN 'MK_REP' THEN salary*1.2
				    ELSE salary
		end FROM employees;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

		SELECT last_name,job_id ,salary,                            //表示的意思与上等同
			decade(job_id,'AD_ASST',salary*1.5
                                        'MK_REP',salary*1.2,
					salary)
		FROM employees;

<=====================================================================================================================================================================>
日期:

	SELECT * FROM emp WHERE hierdate<to_date('1987/4/19','yyyy-mm-dd');
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
oracle中关于日期的操作:

	sysdate : 用于获取系统的当前时间(但不能获取到毫秒数),所以用户 select to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6') from dual; 来代替

	select id,to_char(intime,'yyyy-mm-dd hh24:mi:ss.ff') from t_date;

	insert into t_date(id,intime) values(3,sysdate);

	select to_char(current_timestamp, 'YYYYMMDDHH24MISSXFF') from dual; 

	select to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6') from dual; 

	select to_timestamp('2012-02-03 10:29:46.453234','yyyy-mm-dd hh24:mi:ss.ff6') from dual //将字符型转换为timestamp类型

	select to_timestamp((select to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6') from dual),'yyyy-mm-dd hh24:mi:ss.ff6') from dual

```````````````````````````````

	insert into t_date(id,intime) values(4,(select to_timestamp((select to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6')
 
	from dual),'yyyy-mm-dd hh24:mi:ss.ff6') from dual));  //t_date是wulin用户下自己建的一张测试日期的表

``````````````````````````````````````````

<=====================================================================================================================================================================>

	ORDER BY

		SELECT * FROM emp ORDER BY sal,ename DESC ;   //表示先按照sal进行升序排列,若sal字段中有相同的,
              
                                                              //再按ename 进行降序排列,因为不写升降序关键字默认按照升序排列

               DESC :降序    ASC 升序
			   
<=====================================================================================================================================================================>		   
使用 case when 实现 动态排序		   

	select b.gydwName, --监区名称
	sum(1) gydwNum, -- 监区人数
	sum(case when b.zfztId = 'code_zyxz_1' then 1 else 0 end) groupTraning, --集训
	sum(case when b.zfztId = 'code_zyxz_2' then 1 else 0 end) confinement, --禁闭
	sum(case when b.zfztId = 'code_zyxz_3' then 1 else 0 end) outVisit, -- 离监探亲
	sum(case when b.zfztId = 'code_zyxz_4' then 1 else 0 end) outVisitCharter, -- 特许离监探亲
	sum(case when b.zfztId = 'code_zyxz_5' then 1 else 0 end) outCure, -- 离监就医
	sum(case when b.zfztId = 'code_zyxz_6' then 1 else 0 end) outOther, --其他外出
	sum(case when b.zfztId = 'code_zyxz_7' then 1 else 0 end) comeBack, -- 提回
	sum(case when b.zfztId = 'code_zyxz_10' then 1 else 0 end) medicalParole --保外就医
	 from criminal_base_info b where b.gydwId is not null and b.gydwName is not null 
	 and b.zfztId in ('code_zfzt_1','code_zyxz_1','code_zyxz_2','code_zyxz_3','code_zyxz_4','code_zyxz_5','code_zyxz_6','code_zyxz_7','code_zyxz_8'
	 ,'code_zyxz_9','code_zyxz_10','code_zyxz_11','code_zyxz_12','code_zyxz_13','code_zyxz_14','code_zyxz_15')
	 group by b.gydwName
	 order by case when b.gydwName = '一监区' then 1 
				   when b.gydwName = '二监区' then 2 
				   when b.gydwName = '三监区' then 3 
				   when b.gydwName = '四监区' then 4 
				   when b.gydwName = '五监区' then 5 
				   when b.gydwName = '六监区' then 6 
				   when b.gydwName = '七监区' then 7 
				   when b.gydwName = '八监区' then 8 
				   when b.gydwName = '九监区' then 9 
				   when b.gydwName = '医院' then 10 
               end asc;			   
		
<=====================================================================================================================================================================>	
使用 substr+to_number 实现 动态排序	
	select b.gydwId,b.gydwName,count(1) from criminal_base_info b where b.zfztId = 'code_zfzt_1' 
	group by b.gydwId,b.gydwName order by to_number(SUBSTR(b.gydwId,9,3)) asc;

<=====================================================================================================================================================================>
order by 对空值的控制 
	
	ORDER BY name desc nulls last
	
<=====================================================================================================================================================================>

oracle的函数:

	LOWER(ename);   //转小写                                   //没有特殊说明的情况下,ename统一表示为列名

	UPPER(ename);  //转大写

	INITCAP(ename);   //首字母大写
	
	CONCAT(ename,empno);  //将两个列连接

 	SUBSTR(ename,x,y);   //字符串截取   //x表示从字符串的第几个索引开始 ,y表示要截取的长度

	LENGTH(ename);   //取出该字段的长度

	INSER(ename,w);   //查找ename字段中第一个w的索引

	LPAD(ename,x,y);  //x表示该字段要显示的长度,y表示如若显示字符串不够,则用y表示的字符在左边填充   

	RPAD(ename,x,y);   //x表示该字段要显示的长度,y表示如若显示字符串不够,则用y表示的字符在右边填充   

	TRIM('x' from ename);  //x表示字段ename中要去掉的字符

	ROUND(45.926,2);  //四舍五入 //第二个2表示小数点后面留2位

	TRUNC(45.926,2);  //截取  //第二个2表示小数点后面留2位

	MOD(1600,300);   //求余  //1600表示被除数,300是除数

	instr :          //查找位置	
	
	instr(sourceString,destString,start,appearPosition) 

		instr（'源字符串' , '目标字符串' ,'开始位置','第几次出现'） 

		其中sourceString代表源字符串； 

		destString代表要从源字符串中查找的子串； 

		start代表查找的开始位置，这个参数可选的，默认为1； 

		appearPosition代表想从源字符中查找出第几次出现的destString，这个参数也是可选的， 默认为1 

		如果start的值为负数，则代表从右往左进行查找，但是位置数据仍然从左向右计算。 

		返回值为：查找到的字符串的位置。 
		
	替换字符串
	replace(strSource, str1, str2) 将strSource中的str1替换成str2

	解析：strSource:源字符串
	　　  str1: 要替换的字符串
	  　　str2: 替换后的字符串
		
<=====================================================================================================================================================================>
SQL中的小数点后的输入位数.
	一、用函数 ROUND(数值,s) ， 其中 s 表示 小数位数

	例：SELECT ROUND(4.994,2) 返回 4.990

	二、用函数 CAST(数值 as numeric(n,s))，其中n表示有效数字位数，s表示小数位数,若 数值 是整数 则会自动 在小数点后面补全.00 例如 : 4 --> 4.00

	例：SELECT CAST(4.994 as numeric(10,2)) 返回 4.99

	三、用函数 CONVERT(numeric(n,s),数值)，其中n表示有效数字位数，s表示小数位数

	例: SELECT CONVERT(numeric(10,2),4.985) 返回 4.99
	
<=====================================================================================================================================================================>
修改Oracle最大连接数(方法一下-->未测试)
	1、修改Oracle最大连接数的方法
	   
	   a、以sysdba身份登陆PL/SQL 或者 Worksheet
	   b、查询目前连接数
		  show parameter processes;
	   c、更改系统连接数
		  alter system set processes=1000 scope=spfile;
	   d、创建pfile
		  create pfile from spfile;
	   e、重启Oracle服务或重启Oracle服务器

	2、查询Oracle游标使用情况的方法
	   select * from v$open_cursor where user_name = 'TRAFFIC'；
	3、查询Oracle会话的方法
	   select * from v$session
	   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
修复oracle最大连接数(方法二 -->已经测试-->成功)
	
		查询数据库当前进程的连接数： 

	　select count(*) from v$process; 

	　　查看数据库当前会话的连接数： 

	　　select count(*) from v$session; 

	　　查看数据库的并发连接数： 

	　　select count(*) from v$session where status='ACTIVE'; 

	　　查看当前数据库建立的会话情况： 

	　　select sid,serial#,username,program,machine,status from v$session; 

	　　查询数据库允许的最大连接数： 

	　　select value from v$parameter where name = 'processes'; 

	　　或者：show parameter processes; 

	　　修改数据库允许的最大连接数： 

	　　alter system set processes = 300 scope = spfile; 

	　　(需要重启数据库才能实现连接数的修改) 

	　　重启数据库： 

	　　shutdown immediate; 

	　　startup; 

	　　查看当前有哪些用户正在使用数据： 

	　　select osuser,a.username,cpu_time/executions/1000000's' ,sql_fulltext,machine 

	　　from v$session a,v$sqlarea b 

	　　where a.sql_address = b.address 

	　　order by cpu_time/executions desc; 

	　　备注：UNIX 1个用户session对应一个操作系统process，而Windows体现在线程。 

	　　启动oracle 

	　　su - oracle 

	　　sqlplus system/pwd as sysdba //进入sql 

	　　startup //启动数据库 

	　　lsnrctl start //启动监听 

	　　sqlplus "/as sysdba" 

	　　shutdown immediate; 

	　　startup mount; 

	　　alter database open; 

	-- 

	web应用连接oracle数据库时，经常在查询数据时发生 

	Listener refused the connection with the following error: ORA-12519, TNS:no appropriate service handler found The Connection descriptor used by the client was: 127.0.0.1:1521:ORCL 

	这种错误，网上查了很多，都说是ip地址改变之后的问题，要把tnsnames.ora中的实例配置中改为计算机名，我试过之后问题还是不能解决，今天终于找到问题所在了，是数据库连接数量的问题，12519错误为监听不能提供服务，通常为数据库进程达到上限导致。 

		  可以先执行下 select count(*) from v$process ，看下现在系统有多少连接数，然后再查询 select value from v$parameter where name = 'processes' ，看下oracle设置中设置了多少连接数，一般一个应用都会使用20个，所以如果你开了几个应用的话（web、pl/sql、……）就会出这个问题了，这时只需要执行下 

	alter system set processes = 300 scope = spfile;


	就可以了，当然300可以根据实际情况设置。 

<=====================================================================================================================================================================> 
如何查询出数据库中日期最大的所有数据

	yhh              name    gdcs  gdsj1   gdtime
	600040407    王玲    1    0.56    2011/6/21 22:34    
	600040407    王玲    2    0.56    2011/6/24 10:21    
	600040407    王玲    3    0.56    2011/12/7 10:45    
	600040407    王玲    4    0.56    2012/1/15 14:01    
	600040407    王玲    5    0.56    2012/12/26 14:11    
	600040408    魏武    1    0.56    2011/6/21 22:36    
	600040408    魏武    2    0.56    2013/11/15 10:46    
	600040408    魏武    4    0.56    2014/1/19 9:12    
	600040408    魏武    3    0.56    2014/1/10 13:57    
	600040408    魏武    5    0.56    2014/1/22 10:08  
	600040435    于洋    1    0.56    2011/6/22 12:54    
	600040435    于洋    2    0.56    2013/3/11 9:16    
	600040435    于洋    4    0.56    2014/1/10 11:18    
	600040435    于洋    3    0.56    2013/12/20 15:09

	我知道用 select name,MAX(gdtime) from table1 group by yhh 挑选出每个人的最新登录实际,结果只有name,gdtime
	怎么将每个人的最新登录这条记录全部信息显示出来,不止name,gdtime,我还要yhh  ,gdcs,gdsj1 这几列
	
	
	/* 1 用子查询 */
	select yhh, name, gdcs, gdsj1, gdtime
	from table1
	where exists
	(
		select 1 from
		(
			select yhh, max(gdtime) as gdtime
			from table1 
			group by yhh
		) x
		where x.yhh = table1.yhh 
		  and x.gdtime = table1.gdtime
	)
	 
	/* 2 用窗口函数 */
	select * from
	(
	select yhh, name, gdcs, gdsj1, gdtime
	, max(gdtime) over(partition by yhh) as gdtimeMax
	from table1
	) x
	where gdtime = gdtimeMax
	
	3. /*效率最高效也是最简单的方式*/
	select yhh,name,gdcs,gdsj1,gdtime
	from tab a where not exists(select 1 from tab where yhh=a.yhh and gdtime>a.gdtime)
	
	或者
	
	select c.xm, max(c.cjrq) as cjrq
			from base_changeStrengthen c
			group by  c.xm

<=====================================================================================================================================================================>
instr语法

	语法如下： 
	　　instr( string1, string2, start_position,nth_appearance )

			string1
			 
			源字符串，要在此字符串中查找。

			string2
			 
			要在string1中查找的字符串 。

			start_position
			 
			代表string1 的哪个位置开始查找。此参数可选，如果省略默认为1. 字符串索引从1开始。如果此参数为正，从左到右开始检索，如果此参数为负，从右到左检索，返回要查找的字符串在源字符串中的开始索引。 

			nth_appearance
			 
			代表要查找第几次出现的string2. 此参数可选，如果省略，默认为 1.如果为负数系统会报错。
			 
			注意： 
			　　位置索引号从1开始。
			　　如果String2在String1中没有找到，instr函数返回0。
			　　示例： 
			　　SELECT instr('syranmo','s') FROM dual; -- 返回 1 
			　　SELECT instr('syranmo','ra') FROM dual; -- 返回 3 
			　　SELECT instr('syran mo','a',1,2) FROM dual; -- 返回 0

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle函数substr与instr联合起来使用的案例:

	select sfcode,substr(sfcode,instr(sfcode,'/',2)+1,instr(sfcode,'/',3)-2) from oasys.sa_oporg where sname = '李再强'
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle中将一张表中的某个字段的值 批量(一一对应) 赋予给另一张表的某一个字段或将某张表中某个字段 批量(一一对应) 赋予另一个字段的案例

	首先查询看是否可以:
	
	select (select odd.fdoctypename from oaapp.oa_dc_doc odd where odd.fid = st.sdata1) fdoctypename
	,st.audittypename,st.sname,st.sdata1,st.* from oasys.sa_task st 
	where st.sprocess = '/ED/doc/process/auditDoc/auditDocProcess';

	其次,查询测试可以了后,在来做批量(一一对应) 更新
	update oasys.sa_task st set st.audittypename = (select odd.fdoctypename from oaapp.oa_dc_doc odd where odd.fid = st.sdata1) 
	where st.sprocess = '/ED/doc/process/auditDoc/auditDocProcess';

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle 中使用子查询来显示出不同记录的值

	select sfid,sfcode,
	(select sID from oasys.sa_oporg where scode =(select substr(sfcode,instr(sfcode,'/',2)+1,instr(sfcode,'/',3)-2) from oasys.sa_oporg where sname = '李再强')) aa
	from oasys.sa_oporg where sname = '李再强'

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
nvl()函数的用法:

	NVL(comm,x);    //去null函数,当comm为null时用x替代;

	NVL2(comm,x,y);  //当comm为null时用x替代,否侧用y替代
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

对decode() 与 case 的理解:

	范例:在emp表中,为工作为'CLERK'的员工加薪200,为工作为'SALESMAN'的员工加薪300

	方法一: 用 decode()

	select job , sal ,decode(job,'CLERK',sal+200,'SALESMAN',sal+300,sal) from emp

	方法二: 用 case

	select job,sal,case job when 'CLERK' then sal+200
				when 'SALESMAN' then sal+300
				else sal
				end
	from emp

.......................................   //case 语句组成的字段并不是一个特定的字段,这个字段是有自己拼接而成的

	select job,sal,(case job when 'CLERK' then 'hshs'
        when 'SALESMAN' then 'xixi'
        else 'jjj'
        end) as mysay
	from emp

.....................................

//这两个decode() 与case 表示的意思是 : if(){} if(){} ...else{}..

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

	SELECT ename ,LOWER(ename) FROM dual;  //dual是一张'伪表'


	REPLACE(字符串,字符串1,字符串2);   //将字符串中的字符1替换成字符2;示例: select replace(ename,'SC','SS') from emp; 

	TRANSLATE(字符串,字符串1,字符串2) 替换多的字符;示例: select translate(ename,'SH','AB') from emp; --表示将ename中的'S'换成'A','H'换成'B'; 

	TO_CHAR() 将不是其他类型转成字符类型；对于日期型可以控制其格式:TO_CHAR(日期,'格式');其中格式有: 'YYYY' --以4为显示年;
                   'YEAR' --以标准格式显示年； 'MM' ; 'MON' ; 'DD' ; 'DAY'; 'HH' ; 'MI' ;'SS' 
	TO_x(y); 将y转换为x类型  , x,y的值为 NEMBER ,DATE ,CHAR 中的一个  //例如 : to_date('1987/4/19','yyyy-mm-dd'); to_char(1234);

	SELECT to_char(hiredate,'yyyy/MM/dd') FROM emp
	
	........................................................................
	
	sys_guid() SYS_GUID产生并返回一个全球唯一的标识符(原始值)由16个字节组成。在大多数平台,生成的标识符由主机标符，执行函数的进程或者线程标识符，
	
	和进程或线程的一个非重复的值(字节序列)
	
	sys_guid()这个函数一般要配合rownum使用,例如:
	
	select sys_guid() as guid,rownum from  oasys.sa_task where rownum=1;
	
	........................................................................

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
oracle在没有查询到数据时如何返回一条空数据

	select *
	  from (select rownum r, temp1.*
			  from (select jybh, jymc
					  from t_prison
					 where jybh = '5111111121'
					union all
					select null, null from dual) temp1) temp2
	 where temp2.r = 1

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

to_char()的使用范例:

	select  to_char(hiredate,'yyyy'),
  		to_char(hiredate,'MM'),
		to_char(hiredate,'dd'),
		to_char(hiredate,'yyyy-MM'),
		to_char(hiredate,'yyyy-dd'),
		to_char(hiredate,'MM-dd')
	from emp;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
MONTHS_BETWEEN 的用法 : 

	MONTHS_BETWEEN (x, y)用于计算x和y之间有几个月。如果x在日历中比y早，那么MONTHS_BETWEEN()就返回一个负数。

	当x 和 y 之间的月份之差不是整月的时候，可以采用小数表示，例如

	SELECT MONTHS_BETWEEN('25-MAY-2008', '15-JAN-2008')

	FROM dual;

	MONTHS_BETWEEN('25-MAY-2008','15-JAN-2008')

	4.32258065

	months_between(date1, date2),必须注意的是，date1与date2都为Date类型，不然会出现错误。须用to_date(‘’,'') 来转换为日期格式，才能参加计算

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
类型转换:

	字符--->数值: to_number(x,y);
	字符--->日期: to_date(x,y);
	日期--->字符: to_char(x,y);
	

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
	
分组函数:           说明:一旦用了分组函数,就要用行的思想去思考问题,而不能用列的思想

	AVG(salary)  //平均值

	COUNT(*)  //计行数

	MAX(salary)  //最大值

	MIN(salary)  //最小值

	SUM(salary)  //求和

		例如: SELECT MAX(salary) FROM employees ;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

分组函数的select查询用法:

	SELECT department_id,MAX(salary) FROM employees GROUP BY department_id; //分组函数中select关键字后面只要不是分组函数,就必须再次放在GROUP BY 后面

	SELECT first_name department_id,MAX(salary) FROM employees GROUP BY department_id ,first_name; //表示first_name 与department_id 都相同是,才将其划分为一组
	
	SELECT sum(comm),avg(nvl(comm,0)) FROM emp;  //组函数会对null值进行一定的处理,即忽略null值

	SELECT count(deptno )
	

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
分组函数实例说明:
	
	通过部门进行分组并将部门名称和与之对应的员工平均工资显示出来且要求员工的平均工资大于2000

		//分析:要求是按照部门分组,因为部门下面有部门编号:deptno,部门名称:dname 等等:而又要求显示部门名称,所有我就可以部门名称:deptno进行分组

	SELECT d.dname,avg(e.sal)

	FROM emp e,dept d

	WHERE e.deptno(+)=d.deptno            //要将e.deptno(+)=d.deptno 中的部门全部展开,所以我就要将对方为空的展开,所以就要把(+)放在e.deptno这方

	GROUP BY d.dname

	HAVING avg(e.sal)>2000

方法二:

	SELECT d.dname,avg(e.sal)

	FROM emp e

	RIGHT JOIN dept d

	ON e.deptno=d.deptno

	GROUP BY d.dname

		//说明:方法一的(+) 与方法二的RIGHT 有着相同的作用


方法三:
	
	SELECT d.dname,a.av

	FROM(SELECT deptno,avg(sal) as av FROM emp  GROUP BY deptno) a,dept d
	
	WHERE a.deptno(+)=d.deptno


<=====================================================================================================================================================================>
外键值是可以为null吗?
	外键值可以为null值.
	
<=====================================================================================================================================================================>
char 与 varchar 的区别:
	char 是定长的,而 varchar是变长的.

<=====================================================================================================================================================================>
当表 t_zfjqyd 中的cyzf字段中存储有表bs_dqxx的多个id时,如何采用一对多的思想将两个表中的数据都同时查出来. 
	select z.id,z.spzt,d.dqxxid,d.dqxq,b.xm,b.xb from t_zfjqyd z 
	left join bs_dqxx d on z.cyzf like '%'|| d.dqxxid ||'%'
	left join bs_bsinfo b on b.zfid = d.zfid
	where z.id = '49141e5423294e8b94b0943090382950';

<=====================================================================================================================================================================>

一些名词解释:
	 
	sysdate : 取得当前时间IN

	事务:  两件事同时成功或失败

		事务名词解析:  一旦向数据库中插入或更新或删除一条数据,就开启了一个事务,并且锁住该表,只有commit或rollback后别人才能使用该表

<=====================================================================================================================================================================>

事务隔离级别:
	
	1.未提交读(1):解决了丢失更新
	2.提交读(2):    丢失更新.脏读
	3,可重复读(4):  丢失更新,脏读,不可重复读
	4.串读()8:      丢失更新,脏读,不可重复读,幻读
	
		丢失更新:丢失更新数据
		脏读:(读到未提交读)
		不可重复读:强调数据的新
		幻读:强调数据的增加与删除

<=====================================================================================================================================================================>
	
	子查询中常用的几个;函数:

		in()  //等于(包括)其中一个

		any()  //大于或小于任何一个

		all()  //大于或小于每一个

	对子查询的理解:

		1.子查询一般当做一个表或条件来用
		
		2.在子查询中若子查询最终的值是一个时,可用条件判断 . 若是多行,则当做 表 来用



<=====================================================================================================================================================================>

表与表之间的映射:

	1.多对多

		两张主表中是没有外键的,而中间表只有两个分别应用两张主表的主键的外键列,而这两个外键列共同构成一个主键列




		
		
		

<=====================================================================================================================================================================>
	
oracle中对象:

	表 (TABLE) ,视图(VIEW) ,序列(SEQUENCE),索引(INDEX) ,同义词(SYNONYM)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

创建表语句:

	CREATE TABLE 表名 (字段1 类型1,字段2 类型2,...);

	示例:

	CREATE TABLE t_user(id number(4),name varchar2(10),sex char(2),login_time date);

	char 与 varchar2 的区别:

		char是一个定长度的字符类型,例如:char(6) 占定长的6 个字符 , 而 varchar2 是一个变长度的类型,实际占用几个字节就用几个字节

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
	插入语句insert:
  		
		INSEST INTO 表名(字段1,字段2,...) VALUES(值1,值2,...);

	示列:

		INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) value(8888,'java','java',8989,to_date('1989-12-21','yyyy-MM-dd'),8888,8888,40) ;
		或
		INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) value(8888,'java','java',8989,to_date('1989-12-21','yyyy-mm-dd'),8888,8888,40) ;
		或
		INSERT INTO emp_bak SELECT * FROM emp

		当这两张表不一样时,也可以这样写:
 
		INSERT INTO emp_bak SELECT empno,ename,FROM emp ;	
	
		INSERT INTO 表名1(列名1,列名2,...) SELECT 列名1,列名2,...FROM 表名2

		范例:
			INTERT INTO emp_bak_1(empno)
			SELECT enpno FROM emp_bak
		

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
	
	更新语句update:

		UPDATE 表名 SET 字段1=值1,字段2=值2,... WHERE 条件 

		示例:

			UPDATE emp SET ename='xxx',sal=80000 WHERE empno=9627

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
	重要的更新语句思想范例:

		update xx_emp e
			set e.sal=e.sal+200
			where e.deptno=(select deptno from dept where job="new youk");


----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

	删除语句delete , truncate , drop :

		delete :只删除数据,表还存在,且后面可以加条件进行限制,同时,有事务,即可以回滚

		truncate : 清空表,不能加条件,且不能回滚

		drop : 直接将表删除,且不能回滚

		示例:
		
			DELETE FROM 表名 WHERE 条件

			TRUNCATE TABLE 表名

			DROP TABLE 表名






	总结:增,删,改,查 都可以用子查询替代某些值

<=====================================================================================================================================================================>

	使用其他用户的表的示例:

		SELECT * FROM scott.t_user ;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

一些字段 类型 的说明:

	long:在一个表中只能有一个long 型

	CLOB : 字符数据,最大可达到4G

	BLOB :字节数据,最大可达到4G

	ROWID :确定你的数据存放在磁盘的位置

	示例:

	SELECT rowid ,e.* FROM emp e ;

备份表示例:

	CREATE TABLE emp_bak
	
	AS

	SELECT * FROM emp;

备份表结构:

CREATE TABLE emp_bak2
AS
SELECT * FROM emp WHERE 1=2 ;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

修改表结构:

	ALTER TABLE 表名 ADD(字段1 类型1 );  //增加列

			 MODIFY(字段1 类型1);  //修改类型

			 DROP (字段x); //删除字段

			 DROP UNUSED COLUMNS ;  //删除不可用列


    		 SET UNUSED (字段x) ; //设置该列为不可用列

	//注意:ADD(字段1 类型1 )与 MODIFY(字段1 类型1);的括号中间没有逗号

改变对象的名称,即重命名表

	RENAME DEPT TO DETA;

	TABLE RENAMED

	COMMENT : 给对象加注解

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

	alter 范例:

		alter table 表名 modify (列名 类型 not null); 或 alter table 表名 modify (列名 类型 null)

			//null 或not null表示该列可以null或not null

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
Oracle中已有数据的字段类型修改

	create table t_person(
	id varchar2(200) primary key,
	name varchar2(200),
	address varchar2(200)
	);

	insert into t_person(id,name,address) values(sys_guid(),'zhangsan','beijing');
	insert into t_person(id,name,address) values(sys_guid(),'lisi','shangqiu');

	想把address的varchar2类型改为clob类型

	（1）    //重命名某个字段的名称

	alter table t_person rename column address to myaddress;

	把原字段换个名字，address改为myaddress

	（2）

	alter table t_person add address clob;

	在表中添加一个原字段名字 address 并把类型定义为自己想改变的类型，这里是clob

	（3）

	update t_person set address = myaddress;

	把备份的myaddress字段内容添加到新建字段address中来

	（4）
	alter table t_person drop column myaddress;

	把备份字段myaddress删除

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


约束: 约束是对表里的数据进行约束, 一般在建表时就进行约束

	五种约束:

		NOT NULL :

		UNIQUE   : 唯一约束对null值是不管的,也就是说可以向一个加了唯一约束的列加入多个null值

		PRIMARY KEY 

		FOREIGN KEY

		CHECK : 检查

	主键与唯一键的区别:

		主键不重复,不可用为null值 ,而唯一键不重复,但可以有null值,且可以是多个

	外键的使用条件:

		从表中的外键指向主表中的键必须是唯一键, 一般该键是主表中的主键


<=====================================================================================================================================================================>
oracle 回车、换行符

	1、回车换行符
	chr(10)是换行符，
	chr(13)是回车，
	增加换行符 
	select ' update ' || table_name ||
		   ' set VALID_STATE =''0A'';'||chr(13)||' commit;'
	  from user_tables
	 
	删除换行符
	select id,replace(content,to_char(chr(13))||to_char(chr(10)),'_r_n') from fact_content order by content;
	 
	oracle中去掉文本中的换行符、回车符、制表符小结
	一、特殊符号ascii定义
	制表符 chr(9)
	换行符 chr(10)
	回车符 chr(13)

	二、嵌套使用repalce，注意每次只能提交一个符号，如先回车再换行
			  select REPLACE(gg, chr(10), '') from dual
		要注意chr(13) | | chr(10) 此类结合使用的情况比较多，回车换行在notepad中是比较好看点的，所以要考虑此种情况
			  select translate(string,chr(13)||chr(10),',') from dual;
	 
	三、对于字符大对象的符号处理
		对于clob字段中的符号处理，先to_char然后一样的处理

	SQL> select to_char(vcl),replace(to_char(vcl),chr(10),'[]') from test_1;

<=====================================================================================================================================================================>

语句分类:

	DML(数据操作语言) INSERT UPDATE DELETE

	DDL(数据定义语言) CREATE ,DROP

	DCL(数据控制语言) GRANT REVOKE

<=====================================================================================================================================================================>

	创建表:

		CREATE TABLE 表名

		示例:

		CREATE TABLE all AS SELECT * FROM all_objects;

<=====================================================================================================================================================================>

约束与ALTER 的总结:



约束名指的一个随意的名字只是我们习惯于 ‘ 外键名_FK ’例如 ：fk_id_FK

1、添加列
alter table 表名 add (字段1 类型1);
2、修改列
alter table 表名 modify (字段1 类型1);
3、删除列
alter table 表名 drop (字段1);
alter table 表名 drop column 字段1;
4、添加主键约束
ALTER TABLE   表名
  ADD 约束名 primary key (column);
5、添加外键约束
ALTER TABLE     表名
ADD CONSTRAINT  约束名 
  FOREIGN KEY(列) 
  REFERENCES 被引用的表名(列);
 
6、删除约束
ALTER TABLE      表名
DROP CONSTRAINT  约束名;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

create的使用范例:

CREATE TABLE t_person(pid number primary key,
                      pname varchar2(10),
                      psex char(2));
                      
SELECT * FROM t_person

INSERT INTO t_person(pid,pname,psex)
VALUES(1,'teather','男');

CREATE TABLE t_student(sid number primary key,
                      sname varchar2(10),
                      ssex char(2));
                      
SELECT * FROM t_student

INSERT INTO t_student(sid,sname,ssex)
VALUES(1,'student','男');


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------  
ALTER与 create的使用范例:                    

SELECT *
FROM t_teacher

ALTER TABLE t_student
MODIFY(ssex varchar(4))

ALTER TABLE t_student
ADD(sss char(6))

ALTER TABLE t_student
DROP (SSS)

ALTER TABLE t_student
DROP CONSTRAINT fk_id_FK;

ALTER TABLE t_student
ADD(fk_id number);

ALTER TABLE t_student
ADD CONSTRAINT fk_id_FK FOREIGN KEY(fk_id) references t_person(pid)

create table oaedi.tb_master_item(
       sid number(6) null primary key,
       xmmc varchar2(100) not null,
       sfsp char(1) default '1' null,
       fk_id number(6) null,
       constraint fkid_id_fk foreign key(fk_id) references oaedi.tb_master_item(sid) on delete cascade
);

CREATE TABLE t_ddetailed(
		ddid number(20) primary key,
		ddgoodsid varchar2(50),
		ddprice number(20),
		dingd_id number(20),
		constraint dingd_id_FK foreign key(dingd_id) references t_dingdan(did) on delete cascade
	);

CREATE TABLE t_teacher(
		tid number primary key,
		tname varchar2(10),
		tsex char(2),
		fkid number(4),
		constraint fkid_FK foreign key(fkid) references t_person(pid)
	);

ALTER TABLE emp_bak
  ADD CONSTRAINT FK_DEPTNO1 FOREIGN KEY(deptno)
  REFERENCES dept_bak(deptno) ON DELETE CASCADE;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

增加一列并添加外键约束:

ALTER TABLE t_studentRegister
ADD (sid number,
constraint sid_FK foreign key(sid) references clazz(id) on delete cascade);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何修改一个表的某一列的长度和如何为某一个表的某一个列添加说明(即列的注释):

	alter table AUDIT_PROCESSRECORD modify FACTIVEID VARCHAR2(2);

	comment on column AUDIT_PROCESSRECORD.FACTIVEID
  	is '环节ID(
	接件:01、初审:03、复审:05、建档流转:13、内审:15、科长审批:17、分管局长审批:19、局长审批:21、基金出纳:23、财务科长:25、基金会计:27)';
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查询或统计某一张表中有多少列的两种方式,注意:要区分大小写
		
	select   tname,count(*)   from   col   group   by   tname having tname='OA_DC_DOC';

	select count(column_name) from user_tab_columns where table_name='OA_DC_DOC'
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
将一个表的数据批量插入到另一个字段个数及类型及名称相同的表:
		注意:select 后面最好接具体的字段,不要用*号代替;

	把表gl_acc_item20100706中数据插入到表gl_acc_item中:
	
		insert into gl_acc_item select * from gl_acc_item20100706 t where  t.fiscal ='2010' and t.acc_item_code  = 'ACC_ITEM5' 
		and length( t.gl_item_code)>1 and t.gl_item_code not like '2%';
		
	要修改数据，那么就需要把*换成具体字段，并用'2009'代替fiscal字段，
	比如总共有acc_item_code、fiscal、id、name等几列，就要写成：
	
		insert into gl_acc_item select acc_item_code,'2009',id,name from gl_acc_item20100706 t where  t.fiscal ='2010' 
		and t.acc_item_code  = 'ACC_ITEM5' and length( t.gl_item_code)>1 and t.gl_item_code not like '2%';

<=====================================================================================================================================================================>
oracle中通过存储过程或函数插入多条不同的数据的案例:

	--新建一个表：
	CREATE TABLE HANG2LIE
	(   "ID" NUMBER,
	"NAME" VARCHAR2(20),
	"COURSE" VARCHAR2(20),
	"SCORE" NUMBER
	)
	--在表中插入如下的数据(为了锻炼下pl/sql所以这里费事写了一个PL/SQL程序):
	declare
	   random_var number;
	   course_var varchar2(20);
	begin
	for i in 1..3 loop
	   for j in 1..5 loop
			   select mod(trunc(dbms_random.value(0,100)*190),100) into random_var from dual;
			   case
					   when j=1 then course_var:='语文';
						when j=2 then course_var:='数学';
						when j=3 then course_var:='英语';
						when j=4 then course_var:='历史';
						when j=5 then course_var:='化学';
				end case;
				insert into HANG2LIE(id,name,course,score) values(i,'name_' || i,course_var,random_var);
		end loop;
	end loop;
	end;

<=====================================================================================================================================================================>
oracle使用函数实现计算余刑,即两个日期之前的差值

	create or replace function get_syxq(p_xq in varchar2,p_xqzr in date,p_jzsj in date) return varchar2
	-- 该函数时用于获得剩余余刑的,通过 刑期,刑期止日,截止时间
	as

	r_syxq varchar2(100); -- 返回的剩余刑期

	t_p_xqzr varchar(100) := to_char(p_xqzr,'yyyyMMdd'); --将刑期止日转换为字符串
	t_p_jzsj varchar(100) := to_char(p_jzsj,'yyyyMMdd'); --将截止时间转换为字符串

	t_yy number; --余刑 '年'
	t_y1 number; --刑期止日的 '年'
	t_y2 number; --截止时间的 '年'

	t_mm number; -- 余刑 '月'
	t_m1 number; -- 刑期止日 '月'
	t_m2 number; -- 截止时间 '月'
	t_m1_sy number; -- 求刑期止日上个月的总天数

	t_dd number; -- 余刑 '天'
	t_d1 number; -- 刑期止日 '天'
	t_d2 number; -- 截止时间 '天'

	begin
		 if '无期' = p_xq or '死缓' = p_xq or '死刑' = p_xq then
			r_syxq := p_xq;

		 elsif p_xqzr <= p_jzsj then
			r_syxq := ''; -- 服刑已满

		 else
			t_y1 := to_number(substr(t_p_xqzr,1,4)); --截取刑期止日 '年'
			t_m1 := to_number(substr(t_p_xqzr,5,2)); --截取刑期止日 '月'
			t_d1 := to_number(substr(t_p_xqzr,7,2)); --截取刑期止日 '天'
			
			t_y2 := to_number(substr(t_p_jzsj,1,4)); --截取截止时间 '年'
			t_m2 := to_number(substr(t_p_jzsj,5,2)); --截取截止时间 '月'
			t_d2 := to_number(substr(t_p_jzsj,7,2)); --截取截止时间 '月'
			
			t_yy := t_y1-t_y2; -- 得到余刑 '年'
			t_mm := t_m1-t_m2; -- 得到余刑 '月'
			
			if t_d1<t_d2 then
			  t_mm := t_mm-1;
			  t_m1_sy := t_m1-1; -- 求刑期止日上个月的总天数
			  
			  if t_m1_sy=0 then --表示这应是上一年的12份
				t_m1_sy := 12;
			  end if;
			  
			  if t_m1_sy=2 then --表示该年的2份 
				--2月总天数
				t_m1_sy := (case when mod(t_y1,4)=0 then 29 else 28 end);
				
			  else  
				--其他月总天数
				t_m1_sy := (case when t_m1_sy in(4,6,9,11) then 30 else 31 end);
			  end if;
			  
			   t_d1:=t_d1+t_m1_sy; --刑期止日“天”＋刑期止日上个月的总天数
			end if;
	   
			t_dd:=t_d1-t_d2; --余刑 '天'
			if t_mm <0 then
			   t_yy := t_yy-1;
			   t_mm := t_mm+12;
			  
			end if;
			
			r_syxq := substr(to_char(100+t_yy),2,2)||substr(to_char(100+t_mm),2,2)||substr(to_char(100+t_dd),2,2);   
		 end if;

	return r_syxq;
	end get_syxq;


<=====================================================================================================================================================================>
oracle如何冲查询出来的数据列表中取出第一条数据

	create or replace function get_xqzr(p_zfid in varchar2,p_jzrq in date) return date
	--该函数是用于获得刑期止日的,通过罪犯bh和截止日期
	as
	r_xqzr date; --返回刑期止日
	t_zfid varchar2(100):=p_zfid; -- 罪犯编号
	t_jzrq date:=TO_DATE(to_char(p_jzrq,'yyyy/MM/dd'),'yyyy/MM/dd');
	begin
	  select p4.xqjs into r_xqzr from (
		select rownum as rowNumber ,p3.* from (
			 -- xqjs : 就是刑期止日
			 select p.cjrq,p.xqjs from t_punishment p where p.dqxxid = t_zfid and p.cjrq <= t_jzrq order by p.cjrq desc
		 ) p3
	   ) p4 where p4.rowNumber = 1;

	return r_xqzr;
	end get_xqzr;


<=====================================================================================================================================================================>

视图:

	视图与原表共享一份数据,但是删除视图只是删除视图定义,不会删除基表的数据
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

打开cmd ,输入sqlplus

2.conn/as sysdba

3.grant create view to scott

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
基于表 创建一个视图:

	CREATE VIEW v_emp 

	AS

  	SELECT empno,ename,deptno FROM emp

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
基于表 创建一个不能修改的视图:

	CREATE or replace VIEW v_emp 

	AS (可以重新取名)

  	SELECT empno,ename,deptno FROM emp
	
	WITH read only (只读)



删除视图:

	drop view 视图名

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
关于视图的案例:

	1.................................................................................................................................................................
		create or replace view v_oa_am_recycle as
		select 'bs_master' tbtype,'中间数据' tbtypen,to_char(fmid) fkey,
		to_char(fmid) fid,ftitle
		from oaedi.bs_master
		where fstat = '10'
		union all
		select 'oa_am_archival' tbtype,'档案数据' tbtypen,fid fkey,
		fid,ftitle
		from oa_am_archival
		where fstate = '04'
		union all
		select 'oa_am_archival' tbtype,'案卷数据' tbtypen,fid fkey,
		fid,ftitle
		from oa_am_archival
		where fstate = '14';
	
	2.................................................................................................................................................................
		CREATE OR REPLACE VIEW V_OA_AM_CATEGORYSELECT AS
		select c.fid,
			   fc.ffondsid,
			   f.ffondsno,
			   f.ffondsname,
			   c.fcategoryno,
			   c.fcategoryname,
			   c.fcategoryurl,
			   c.fCategoryURLName,
			   c.fparentid,
			   c.fkeeplimit,
			   c.fkeeplimitname,
			   c.fbscategoryno,
			   0 as version
		  from OA_AM_fondscategory fc
		  join OA_AM_category c on c.fid = fc.fcategoryid
							   and c.fusestatus = 1
		  join OA_AM_fonds f on f.fid = fc.ffondsid
							and f.fallcategory = 0
							and f.fusestatus = 1
		union (select c.fid,
			   f.fid,
			   f.ffondsno,
			   f.ffondsname,
			   c.fcategoryno,
			   c.fcategoryname,
			   c.fcategoryurl,
			   c.fCategoryURLName,
			   c.fparentid,
			   c.fkeeplimit,
			   c.fkeeplimitname,
			   c.fbscategoryno,
			   0 as version
		  from OA_AM_fonds f
		  join OA_AM_category c on c.fParentid = '_is_root_'
							   and c.fusestatus = 1 and f.fallcategory = 1)
		union (select fid,
					  null,
					  null,
					  null,
					  fcategoryno,
					  fcategoryname,
					  fcategoryurl,
					  fCategoryURLName,
					  fparentid,
					  fkeeplimit,
					  fkeeplimitname,
					  fbscategoryno,
					  0 as version
				 from OA_AM_category
				where fusestatus = 1 and fParentID <> '_is_root_')
		 order by fcategoryno;

	
	3.................................................................................................................................................................
		create or replace view v_oa_am_archivalurlinfo as
		select a1.fid,
			   a1.ffileno,
			   a1.famyear,
			   case
				 when a2.fid = a1.fid then
				  null
				 else
				  a2.fid
			   end as rollid,
			   case
				 when a2.fid = a1.fid then
				  null
				 else
				  a2.ffileno
			   end as rollno,
			   a2.ffondsid,
			   f.ffondsno as fondsno,
			   a2.fcategoryid,
			   c.fcategoryno as categoryno
		  from (select fid,
					   ffileno,
					   famyear,
					   case
						 when frollid is null then
						  fid
						 else
						  frollid
					   end as aID
				  from OA_AM_archival) a1
		  join OA_AM_archival a2 on a2.fid = a1.aid
		  join OA_AM_fonds f on f.fid = a2.ffondsid
		  left join OA_AM_category c on c.fid = a2.fcategoryid;

	
	4.................................................................................................................................................................
		create or replace view oa_pub_execute as
		select  replace(sys_guid(), '-', '') as fid,
						t.SDATA1 as fMasterID,
						t.sid as ftaskid,
						'' FACTIVITYFNAME,
						'' FACTIVITYLABEL,
						t.sContent FOPINION,
						'' FVERDICT,
						t.sstatusid FSTATE,
						t.sstatusname FSTATENAME,
						t.sexecutorognid FCREATEOGNID,
						t.sexecutorognname FCREATEOGNNAME,
						t.sexecutordeptid FCREATEDEPTID,
						t.sexecutordeptname FCREATEDEPTNAME,
						t.sexecutorposid FCREATEPOSID,
						t.sexecutorposname FCREATEPOSNAME,
						t.sexecutorpersonid FCREATEPSNID,
						t.sexecutorpersonname FCREATEPSNNAME,
						t.sexecutorfid FCREATEPSNFID,
						t.sexecutorfname FCREATEPSNFNAME,
						t.sactualstarttime FCREATETIME,
						t.sexecutorpersonid FUPDATEPSNID,
						t.sexecutorpersonname FUPDATEPSNNAME,
						t.sactualfinishtime FUPDATETIME,
						t.version VERSION,
						t.stypename FBIZKIND
		  from oasys.sa_task t
		 where t.skindid = 'tkTask';

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

	describe 表名

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
用sql语句查询 来 模仿 desc 

	//1.查出某个表的所有列的属性
	SELECT * FROM user_tab_columns t WHERE t.TABLE_NAME='BS_BSINFO'
	
	//2.查出某个表的所有列的属性及所属用户
	SELECT * FROM all_tab_columns t WHERE t.OWNER='ZFJC' AND t.TABLE_NAME='BS_BSINFO'
	
	//3.查询某个表的所有列的comments
	select * from USER_COL_COMMENTS c where c.TABLE_NAME = 'BS_BSINFO';
	
	//4.查出某个表的所有列的属性及comments
	SELECT distinct c.TABLE_NAME,c.COLUMN_NAME,c.COMMENTS,tc.DATA_TYPE,tc.NULLABLE,tc.CHAR_LENGTH FROM USER_COL_COMMENTS c
	left join all_tab_columns tc on c.COLUMN_NAME = tc.COLUMN_NAME
	WHERE c.TABLE_NAME = 'BS_BSINFO' and tc.TABLE_NAME= 'BS_BSINFO';

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

在工具中更改数据

select * from v_emp for update ;


<=====================================================================================================================================================================>
rownum:

	rowid:是一个伪列,表示一条记录放在磁盘中什么的位置
	rownum :是一个伪列,主要是用来做分页的,生成连续的列

	SELECT rownum ,e.* from emp e

	rownum 的取值永远是从一开始的

	对于SELECT e.* FROM emp e ORDER BY e.sal desc 语句,它是先列出rownum号后再排序的 .


<=====================================================================================================================================================================>
对rownum的理解:  

	SELECT a.* FROM (
			SELECT rownum r,e.*
			FROM emp e
			WHERE rownum<=7
			) a
	WHERE a.r>=5
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
	SELECT * FROM (
			SELECT rownum r,a.*
			FROM (
				SELECT e.*
				FROM emp e
				ORDER BY e.sal desc
				) a
			) b
	WHERE b.r>=5 AND b.r<=7

<=====================================================================================================================================================================>
序列:

	CREATE sequence seq_emp

	SELECT seq_emp.nextval from dual (只显示下一个值)

	SELECT sep_emp.currval from dual (显示当前序列值)

	DROP SEQUENCE 	序列名

范例:

	CREATE SEQUENCE seq_myemp

	CREATE TABLE t_myemp (id number(4) primary key,name varchar2(10),sex char(2));


	INSERT INTO t_myemp(id,name,sex) VALUES (seq_myemp.nextval,'haha','男');

	SELECT seq_myemp.currval from t_myemp

	SELECT sep_myemp.currval from dual
	


<=====================================================================================================================================================================>

索引:   select * from  表名 where 条件  ,这时才使用索引,即一般索引用在大表中条件查询中,即提高性能,否则没有什么意义

	
   创建索引:

	CREATE INDEX idx_emp

	ON 表名(列名)
	
	或

	CREATE INDEX idx_emp ON 表名(列名1,列名2,..)

   删除索引:

        DROP INDEX 索引名

// 常见的索引有:唯一索引,函数索引,

<=====================================================================================================================================================================>
查看索引个数和类别:

	select * from user_indexes where table_name='表名' ;

<=====================================================================================================================================================================>

oracle在cmd中使用的循环语句范例:

	begin 
		for  i in 1..5 loop
		insert into  表名1 as
		select * from 表名1
		commit;
	 	end loop;
	end





<=====================================================================================================================================================================>

同义词:  //方便访问其他用户的对象

	create synonym emp for scott.emp 

删除同义词:

	drop synonym 同义词名

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

同义词的使用范例:

	1.打开cmd输入sqlplus/nolog 
	2.conn/as sysdba
	3.show user  //显示当前用户
	4.select * from scott.emp //调用其他用户的表
	5.create synonym emp for scott.emp  //为其他用户的表在该用户下创建一个同义词为emp的表名称
	6.select * from emp  //使用同义词名在当前用户下查看其他用户的名称


<=====================================================================================================================================================================>
Oracle中查看所有表和字段

	获取表：
	select table_name from user_tables; //当前用户拥有的表      
	 
	select table_name from all_tables; //所有用户的表 
	select table_name from dba_tables; //包括系统表
	select table_name from dba_tables where owner='用户名'
	 
	user_tables：
	table_name,tablespace_name,last_analyzed等
	dba_tables：
	ower,table_name,tablespace_name,last_analyzed等
	all_tables：
	ower,table_name,tablespace_name,last_analyzed等
	all_objects：
	ower,object_name,subobject_name,object_id,created,last_ddl_time,timestamp,status等
	 
	 获取表字段：
	select * from user_tab_columns where Table_Name='用户表';
	select * from all_tab_columns where Table_Name='用户表';
	select * from dba_tab_columns where Table_Name='用户表';
	user_tab_columns：
	table_name,column_name,data_type,data_length,data_precision,data_scale,nullable,column_id等
	all_tab_columns ：
	ower,table_name,column_name,data_type,data_length,data_precision,data_scale,nullable,column_id等
	dba_tab_columns：
	ower,table_name,column_name,data_type,data_length,data_precision,data_scale,nullable,column_id等
	获取表注释：
	select * from user_tab_comments
	user_tab_comments：table_name,table_type,comments
	相应的还有dba_tab_comments，all_tab_comments，这两个比user_tab_comments多了ower列。
	获取字段注释：
	select * from user_col_comments
	user_col_comments：table_name,column_name,comments
	相应的还有dba_col_comments，all_col_comments，这两个比user_col_comments多了ower列。

<=====================================================================================================================================================================>
权限:

	1.打开cmd,输入sqlplus/nolog
	2.conn /as sysdba
	3.create user 用户名 identified by 密码  //创建一个用户
	4.create role 角色名
	5.grant create session ,create table,create view 角色名
	6.grant 角色名 to 用户名

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
grant 权限 to 用户名 (角色)          //这里的权限指的是:select ,update,insert ,delete,或 create session,create table ,create view 等数据库对象
grant 权限 on 对象名 to 用户名
revoke 权限 on 对象名  from 用户名(角色)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
我在oaapp用户的存储过程中要使用oaedi用户下的表tb_request_master的授权方式如下:

	grant select ,insert,update ,delete on tb_request_master to oaapp;  //这才是主要的
	GRANT DBA TO oaapp; --授予DBA权限
	GRANT UNLIMITED TABLESPACE TO oaapp;--授予不限制的表空间
	GRANT SELECT ANY TABLE TO oaapp; --授予查询任何表
	GRANT SELECT ANY DICTIONARY TO oaapp;--授予 查询 任何字典    
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Oracle中connect,resource角色权限

	connect resource权限
		grant connect,resource to user;
	   执行上面的sql语句后用户包括的权限:
		CONNECT角色： --是授予最终用户的典型权利，最基本的
			ALTER SESSION --修改会话
			CREATE CLUSTER --建立聚簇
			CREATE DATABASE LINK --建立数据库链接
			CREATE SEQUENCE --建立序列
			CREATE SESSION --建立会话
			CREATE SYNONYM --建立同义词
			CREATE VIEW --建立视图
		RESOURCE角色： --是授予开发人员的
			CREATE CLUSTER --建立聚簇
			CREATE PROCEDURE --建立过程
			CREATE SEQUENCE --建立序列
			CREATE TABLE --建表
			CREATE TRIGGER --建立触发器
			CREATE TYPE --建立类型
		从dba_sys_privs里可以查到:
		SQL> select grantee,privilege from dba_sys_privs where grantee='RESOURCE' order by privilege;
		GRANTEE PRIVILEGE
		------------ ----------------------
		RESOURCE CREATE CLUSTER
		RESOURCE CREATE INDEXTYPE
		RESOURCE CREATE OPERATOR
		RESOURCE CREATE PROCEDURE
		RESOURCE CREATE SEQUENCE
		RESOURCE CREATE TABLE
		RESOURCE CREATE TRIGGER
		RESOURCE CREATE TYPE
		已选择8行。

	1.查看所有用户：
	  select * from dba_users;
	  select * from all_users;
	  select * from user_users;
	2.查看用户或角色系统权限：
	  select * from dba_sys_privs;
	  select * from user_sys_privs;
	3.查看用户对象权限：
	  select * from dba_tab_privs;
	  select * from all_tab_privs;
	  select * from user_tab_privs;
	4.查看所有角色：
	  select * from dba_roles;
	5.查看用户或角色所拥有的角色：
	  select * from dba_role_privs;
	  select * from user_role_privs;
	 
	 
	注意：
	1、以下语句可以查看Oracle提供的系统权限
	select name from sys.system_privilege_map
	 
	2、查看一个用户的所有系统权限(包含角色的系统权限)

	select privilege from dba_sys_privs where grantee='DATAUSER'  
	union  
	select privilege from dba_sys_privs where grantee in (select granted_role from dba_role_privs where grantee='DATAUSER' ); 
	
	注意:这里resource权限同时也有select,update,insert,delete等权限
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何oracle 某一用户授予查询另一个用户某张表的权限，以及更新另一用户表中某些字段(查看表所对应的用户 及表所在用户)

	create user dwtest identified by ST/G00100000161;
	grant connect to dwtest;
	grant select on stpt.dw_metro_production  to dwtest;

	Ex:
	select * from stpt.dw_metro_production t  
	查看该表 表结构
	select * from user_tab_columns where Table_Name='用户表'; 
	select * from all_tab_columns where Table_Name='用户表'; 
	select * from dba_tab_columns where Table_Name='用户表'; 

	sqlplus userA

	grant select on userA.the_table to userB;
	grant update (the_column) on the_table to userB;

	1。查看表结构：desc表名
	2。查看当前用户的表：
	select table_name from user_tables;
	3.查看所有用户的表名：
	select table_name from all_tables;
	4.查看所有表名（其中包括系统表）
	select table_name from dba_tables;
	5.查看所有的表: 
	select * from tab/dba_tables/dba_objects/cat;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
解决Oracle数据库用hibernate在不同用户之间建立相同表名

	1.在hiberante.properties文件里，设置hibernate.default_schema="用户名"，注：用户名要大写
	
.................................................................................................................................................
	
	2. 但是上面解决放方案并不专业,对应oracle数据库,我们用hibernate建表,为了 解决Oracle数据库用hibernate在不同用户之间建立相同表名 ,我们应该授予如下的权限
	
	revoke dba from 用户名
	grant connect,resource to 用户名;
	
	GRANT debug any procedure, debug connect session to 用户; -- 该权限角色是开发人员需要编写存储过程调试是才赋予该角色权限.
	
	之所以删除用户的dba权限,是因为拥有dba权限时,hibernate在创建表时会检查整个表空间乃至这个数据库(即sid:数据库实例),看是否有该表,而授予connect权限,是因为
	要让该用户有登陆数据库的权限,授予resources,resources角色权限是开发者权限,是让该用户拥有创建表,存储过程...等等权限
	同时,为了防止同一个表空间下要让hibernate在多个用户要创建相同表名的表,最好是一个用户对应一个表空间

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
使用sys用户查看其它用户的用户名及密码及表空间:

	select username,password from dba_users;
	
	select default_tablespace,username from dba_users where username='NEWYZ';
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
查看当前用户所在表空间

	select username,default_tablespace from user_users;
	
	//修改用的所在的表空间
	alter user 用户名 default tablespace 新表空间; 
	
	//查看用户自身的权限
	select * from user_role_privs; 
	
	查看用户自身的表
	select * from user_tables;
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
使用system(oracle的管理员用户)查询当前数据库中表空间使用情况(例如已经使用表空间的大小,未使用表空间的大小等)
	SELECT UPPER(F.TABLESPACE_NAME) "表空间名",
	D.TOT_GROOTTE_MB "表空间大小(M)",
	D.TOT_GROOTTE_MB - F.TOTAL_BYTES "已使用空间(M)",
	TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2),'990.99') "使用比",
	F.TOTAL_BYTES "空闲空间(M)",
	F.MAX_BYTES "最大块(M)"
	FROM (SELECT TABLESPACE_NAME,
	ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES,
	ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES
	FROM SYS.DBA_FREE_SPACE
	GROUP BY TABLESPACE_NAME) F,
	(SELECT DD.TABLESPACE_NAME,
	ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB
	FROM SYS.DBA_DATA_FILES DD
	GROUP BY DD.TABLESPACE_NAME) D
	WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME
	ORDER BY 4 DESC

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

两台电脑间数据库连接:

	grant database link to scott
	create database link 库名 connect to scott using 连接方式 
	select * from 表名@库名



<=====================================================================================================================================================================>

select * from emp where empno=7369 for update  //锁定empno=7369 这条记录

select * from emp for update //锁定emp 这张表


----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

union :行连接,即去除重复行,也就是相同的只显示一份,即相当于数学中的取并集 ( 当然连接的两张表的表结构相同,即字段类型与字段数量要相同,即匹配)

	范例:
	
	select * from emp  

	union

	select * emp_bak

union all :进行数据连接,但是不去除重复行

<=====================================================================================================================================================================>

intersect //表达的意思与union相似,只是intersect是取两张表的交集

范例

	select * from emp 

	intersect

	select * emp_bak

<=====================================================================================================================================================================>

minus (减) //即减去相同部分,留下不同的被减数部分(当然操作这一切的前提是字段数量与字段类型要匹配)

	select * from emp 

	minus

	select * emp_bak 

<=====================================================================================================================================================================>

GROUP BY 子句的扩展:  rollup
	
	rollup的使用范例:

		select deptno ,job,sum(sal) from emp
		group by rollup(deptno,job)   //首先按deptno ,job 分组,再按deptno 分组,即按从右到左进行分组,最后执行分组函数( sum() , count() , ...) 当然一般都用sum()
						进行统计,按deptno进行统计结果

<=====================================================================================================================================================================>

排序 order by 的高级应用:
	
	范例:
		select empno,ename from emp e 
		order by ( select dname from dept d 
			   where e.deptno=d.deptno)

<=====================================================================================================================================================================>

exists 操作符:

	范例 : 找出工资大于2000 且emp 表的deptno 在dept 表中存在
	
	方法1:
		select * from emp e where e.deptno in( select deptno from dept ) and e.sal>2000

	方法2:
		select e.* from emp e where exists (
		select d.* from dept d
		where e.deptno = d.deptno ) and e.sal>2000

		//这条语句 where e.deptno = d.deptno 表示emp 表中deptno 在 dept 表中deptno列存在

	//能够用exists 替换 in 的地方就尽量用exists,因为用exists 的性能更高

<=====================================================================================================================================================================>

相关更新 update

	范例:
	
	update emp_bak_1 e1
	set ename=( select ename from emp_bak e where e1.empno=e.empno)

<=====================================================================================================================================================================>

相关删除 delete 

	范例:

	delete from emp_bak_1
	where ename=(select ename from emp_bak e where e1.empno=e.empno)

	方法二:

	delete from emp_bak eb
	where exists ( select 1 from emp e
			where eb.empno=e.empno);

<=====================================================================================================================================================================>

with子句:

	with
	w_emp as ( select deptno ,sum(sal)
			    from emp group by deptno)
	select * from w_emp

	//with 语句相当于是为括号里的子句起一个别名为w_emp的名称
	

<=====================================================================================================================================================================>

oracle理论部分:

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

1.oracle server

  1.1 : instance 

    1.1.1 一大块的内存(sgr [system global area]) 
      1.1.1.1 : database buffer cache
      1.1.1.2 : redo log buffer
      1.1.1.3 : shared pool 
        1.1.1.3.1 : library cache
        1.1.1.3.2 : data dictionary cache


    1.1.2 后台进程
      1.1.2.1 dbwn :database buffer cache 向着里面写
      1.1.2.2 sgwr :将 redo log buffer 向这里面
      1.1.2.3 smon :做清洁工作
      1.1.2.4 pmon :是一个监视进程
      1.1.2.5 ckpt :是检查点进程

  1.2 : database : 磁盘上存的一堆文件 
    1.2.1 : data file(数据文件)
    1.2.2 : control file (控制文件)
    1.2.3 : redo log file (重要日志文件)
      1.2.3.1 : 记录重要文件的操作,且相同的日志多份
    1.2.4 : archive log file (归档日志文件)
    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

oracle 数据库中常见的问题:

	1.用户访问时如何访问的:1.先进入instance ,再进入database
	2.同时多个instance 可以只对应一个database ,即多对一的关系
	3.instance是客户端与databace的中间介质
	4.把数据库停掉其实停掉的是instance
	5.oracle中的经典错误,ora-01555 : (回滚段[rollback]) : 解决方案:1.分次提交,2.减小事务的开启时间

----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

如何在cmd中停掉与开启数据库:

	1.打开cmd命令,输入sqlplus/nolog
	2.conn/as sysdba
	3.shutdown immediate :关闭数据库
	4.shartup 启动数据库


<=====================================================================================================================================================================>

简单sql优化:

	1.能利用索引的尽可能的用索引
	2.能用exists的尽量用exists
	3.like 尽量用'x%',而不用'%x'这种形式,因为第一种要走索引,而'%x'不走索引,若真有这种需求,想办法用其他方法实现
	4.子查询的嵌套不要太深

<=====================================================================================================================================================================>
oracle中存储过程与触发器的混合使用

		--1.所用用户为wulin,创建表为t_book,t_user

	  create table t_user(
		   id number(12) primary key,
		   username varchar2(21),
		   age number(4),
		   gender varchar2(4),
		   password varchar2(21)
	  );

	  create table t_book(
		   id number(12) primary key,
		   bookname varchar2(21)
	  );

	 -- 2.向表t_user中插入值
	  insert into t_user(id,username,age,gender,password) values(7,'wulin_7',25,'男','123456');

	  --3.创建存储过程
	  create or replace procedure insert_proce(id1 in number,bookname1 in varchar2,judge in varchar2) is 
	  begin
		if 'inserting' = judge then
		  insert into t_book(id,bookname) values(id1,bookname1);
		elsif 'updating' = judge then
		  update t_book b set b.bookname=bookname1 where b.id=id1;--存储过程的参数名称必须与所修改的表的字段名不同,否则会出现意想不到的错误
		  dbms_output.put_line('id : '||id1||' ,bookname : '||bookname1);
		elsif 'deleting' = judge then
		   insert into t_book(id,bookname) values(id1,'deleting');
		end if;
	  end;

	  --4.创建表t_user触发器,并调用存储过程
	  create or replace trigger insert_trigger
	  before insert or update or delete
	  on wulin.t_user
	  for each row
	  declare newId t_user.id%type;
	  begin
		if inserting then
		select wulin_sequence.nextval into :new.id from dual;
		insert_proce(:new.id,:new.username,'inserting');
		elsif updating then
		insert_proce(:new.id,:new.username,'updating');
		elsif deleting then
		select wulin_sequence.nextval into newId from dual;
		insert_proce(newId,:new.username,'deleting');
		end if;
	  end;

	 -- 5.创建表t_user触发器,使用insert into 插入值
	  create or replace trigger insert_trigger
	  before insert
	  on wulin.t_user
	  for each row
	  begin
		insert into t_book(id,bookname) values(:new.id,:new.username);
	  end;
	  
	  -- 6.为t_book表添加一列curentTim,类型为timestamp
	  alter table t_book add(curentTim timestamp);
	  
	  -- 7.为t_book表创建一个t_book_trigger的触发器
	  create or replace trigger t_book_trigger
	  before insert or update or delete
	  on wulin.t_book
	  for each row
		begin
		  if inserting then
			select to_timestamp((to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6')),'yyyy-mm-dd hh24:mi:ss.ff6') into :new.curenttim from dual;
		  elsif updating then
			select to_timestamp((to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6')),'yyyy-mm-dd hh24:mi:ss.ff6') into :new.curenttim from dual;
		  elsif deleting then
			select to_timestamp((to_char(current_timestamp, 'yyyy-mm-dd hh24:mi:ss.ff6')),'yyyy-mm-dd hh24:mi:ss.ff6') into :new.curenttim from dual;
		  end if;
		end;
	  
	  -- 9.set serveroutput on; 打开输出选项
	  
	  -- 10.创建一个序列 wulin_sequence ,用作于表的主键
	  create sequence wulin_sequence;
	  
	  案例二:
	  
		create sequence hibernate_sequence
		start with 1
		increment by 1
		minvalue 1
		nomaxvalue
		cache 50
		order
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle存储过程的高级用法案例:

	create or replace procedure createAuditData as
		vs_fid     varchar2(32);
		vs_sid1    varchar2(32);
		vs_sid2    varchar2(32);
		vs_sid3    varchar2(32);
		vs_sid4    varchar2(32);
		vs_ftitle  varchar2(32);--标题变量
		vs_fdoctype varchar2(32);--业务类型变量
		vs_fdoctypename varchar2(32);--类型名称
		vs_sprocess varchar2(132);
		vs_sprocessname  varchar2(132);
		vs_scurl varchar2(132);
		vs_seurl varchar2(132);
		begin
		  declare cursor c_job
			   is
			   select am.fid ,am.ftitle,am.fbstype,am.fsoper,am.fsdate from oaedi.audit_master am
			   where am.fstat ='01'; --生成标题
			   --定义一个游标变量v_cinfo c_emp%ROWTYPE ，该类型为游标c_emp中的一行数据类型
			   c_row c_job%rowtype;
		  begin
			   for c_row in c_job loop
				   update oaedi.audit_master am set am.fstat='02',am.froper_app='system',am.frdate_app=sysdate where  am.fid=c_row.fid;
				   select sys_guid() into vs_fid from oaapp.oa_dc_doc  where rownum=1;-- 生成公文FID
				   dbms_output.put_line(' vs_fid:'||vs_fid||'  --  '||'fmid:'||c_row.fid||'  --  '||'ftitle:'||c_row.ftitle);
				   if c_row.fbstype ='10' then
					  vs_ftitle := '缴费稽核';
					  vs_fdoctype := '10';
					  vs_fdoctypename := '缴费稽核';
					  vs_sprocess := '/ED/doc/process/auditDoc/auditDocProcess';
					  vs_sprocessname := '缴费稽核';
					  vs_scurl := 'auditDoc';
					  vs_seurl := 'auditDoc';
				   elsif  c_row.fbstype ='20' then
					  vs_ftitle := '拨付审批';
					  vs_fdoctype := '20';
					  vs_fdoctypename := '拨付审批';
					  vs_sprocess := '/ED/doc/process/auditBFSPDoc/auditBFSPDocProcess';
					  vs_sprocessname := '拨付审批';
					  vs_scurl := 'auditBFSPDoc';
					  vs_seurl := 'auditBFSPDoc';
				   end if;
				   --业务信息  fExtendStr2 对应中间库 audit_detail 的 fmid以及audit_master的 fid
				   insert into oaapp.oa_dc_doc(fid,fdoctype,fdoctypename,ftitle,fbizstate,fbizstatename,fcurrentactivities,fcurrentexecutors,fcreatepsnid,fcreatepsnname,fcreatetime,fDraftPerName,fDraftTime,fstat,fstat1,fExtendStr2)
				   values(vs_fid,vs_fdoctype,vs_fdoctypename,c_row.ftitle,'bsExecuting','处理中','科室负责人签字','system','',c_row.fsoper,c_row.fsdate,c_row.fsoper,c_row.fsdate,'0','0',c_row.fid);
				    --此处在声明一个游标,在嵌套一个循环
					declare cursor c_sid2_tables 
					   is
					   select ap.fpersoncode vs_audit_person_sa_oporg_sid2 from oaedi.audit_persons ap where ap.forgancode = vs_audit_person_sa_oporg_sid;
					   --定义一个游标变量v_cinfo c_emp%ROWTYPE ，该类型为游标c_emp中的一行数据类型
					   c_sid2_rows c_sid2_tables%rowtype;
					   begin
						  dbms_output.put_line('开始输出');
						  for c_sid2_rows in c_sid2_tables loop
							  dbms_output.put_line('开始输出'||c_sid2_rows.vs_audit_person_sa_oporg_sid2);
						  end loop;
					   end;
				   -- 获取guid
				   select sys_guid() into vs_sid1 from  oasys.sa_task where rownum=1;
				   -- 1 任务1
				   insert into oasys.sa_task(sid,sparentid,sname,sflowid,sdata1,sdata2,scatalogid,skindid,sexecutemode,spreemptmode,sstatusid,sstatusname,stypeid,stypename,saiid,saistatusid,slock,
				   screatorfname,sCreatorPersonName,screatetime,sexecutornames,sexecutorfid,sexecutorfname,sexecutorognid,sexecutorognname,
				   sprocess,sprocessname,sactivity,sactivityname,sactivitynames,scurl,seurl,
				   version,sExecutorPersonID,sExecutorPersonName,sExecutorDeptName,sActualStartTime,sActualFinishTime
				   ) values (
				   vs_sid1,'',c_row.ftitle,vs_sid1,vs_fid,c_row.fid,'tsProcess','tkProcessInstance','','','tesExecuting','正在处理',vs_fdoctype,vs_fdoctypename,'','',sys_guid(),
				   c_row.fsoper,c_row.fsoper,c_row.fsdate,'system','','','','',
				   vs_sprocess,vs_sprocessname,'','','科室负责人签字','','',
				   '0','','','',sysdate,''
				   );
				   dbms_output.put_line('vs_sid1:'||vs_sid1||'  --  '||'sdata1:'||vs_fid);
				   -- 获取guid
					select sys_guid() into vs_sid2 from  oasys.sa_task where rownum=1;
				   --2 初审任务
				   insert into oasys.sa_task(sid,sparentid,sname,sflowid,sdata1,sdata2,scatalogid,skindid,sexecutemode,spreemptmode,sstatusid,sstatusname,stypeid,stypename,saiid,saistatusid,slock,
				   screatorfname,sCreatorPersonName,screatetime,sexecutornames,sexecutorfid,sexecutorfname,sexecutorognid,sexecutorognname,
				   sprocess,sprocessname,sactivity,sactivityname,sactivitynames,scurl,seurl,
				   version,sExecutorPersonID,sExecutorPersonName,sExecutorDeptName,sActualStartTime,sActualFinishTime
				   ) values (
				   vs_sid2,vs_sid1,c_row.ftitle,vs_sid1,vs_fid,c_row.fid,'tsProcess','tkTask','temPreempt','tpmOpen','tesFinished','完成',vs_fdoctype,vs_fdoctypename,vs_sid2,'end',sys_guid(),
				   c_row.fsoper,c_row.fsoper,c_row.fsdate,'system','/ORG01.ogn/PSN01@ORG01.psm','/资阳市医保局/system','ORG01','资阳市医保局',
				   vs_sprocess,vs_sprocessname,'draftActivity','初审','','/ED/doc/process/'||vs_scurl||'/draftActivity.w','/ED/doc/process/'||vs_seurl||'/draftActivity.w',
				   '0','system','system','',sysdate,sysdate
				   );
				   dbms_output.put_line('vs_sid2:'||vs_sid2||'  --  '||'sdata1:'||vs_fid);
				   -- 获取guid
				   select sys_guid() into vs_sid3 from  oasys.sa_task where rownum=1;
				   --3 复审任务
				   insert into oasys.sa_task(sid,sparentid,sname,sflowid,sdata1,sdata2,scatalogid,skindid,sexecutemode,spreemptmode,sstatusid,sstatusname,stypeid,stypename,saiid,saistatusid,slock,
				   screatorfname,sCreatorPersonName,screatetime,sexecutornames,sexecutorfid,sexecutorfname,sexecutorognid,sexecutorognname,
				   sprocess,sprocessname,sactivity,sactivityname,sactivitynames,scurl,seurl,
				   version,sExecutorPersonID,sExecutorPersonName,sExecutorDeptName,sActualStartTime,sActualFinishTime
				   ) values (
				   vs_sid3,vs_sid1,c_row.ftitle,vs_sid1,vs_fid,c_row.fid,'tsProcess','tkTask','temPreempt','tpmOpen','tesFinished','完成',vs_fdoctype,vs_fdoctypename,vs_sid3,'end',sys_guid(),
				   c_row.fsoper,c_row.fsoper,c_row.fsdate,'system','/ORG01.ogn/PSN01@ORG01.psm','/资阳市医保局/system','ORG01','资阳市医保局',
				   vs_sprocess,vs_sprocessname,'checkActivity','复审','','/ED/doc/process/'||vs_scurl||'/draftActivity.w','/ED/doc/process/'||vs_seurl||'/checkActivity.w',
				   '0','system','system','',sysdate,sysdate
				   );
				   dbms_output.put_line('vs_sid3:'||vs_sid3||'  --  '||'sdata1:'||vs_fid);
				   -- 获取guid
				   select sys_guid() into vs_sid4  from oasys.sa_task where rownum=1;
				   --4 科室审批任务
				   insert into oasys.sa_task(sid,sparentid,sname,sflowid,sdata1,sdata2,scatalogid,skindid,sexecutemode,spreemptmode,sstatusid,sstatusname,stypeid,stypename,saiid,saistatusid,slock,
				   screatorfname,sCreatorPersonName,screatetime,sexecutornames,sexecutorfid,sexecutorfname,sexecutorognid,sexecutorognname,
				   sprocess,sprocessname,sactivity,sactivityname,sactivitynames,scurl,seurl,
				   version,sExecutorPersonID,sExecutorPersonName,sExecutorDeptName,sActualStartTime,sActualFinishTime
				   ) values (
				   vs_sid4,vs_sid1,c_row.ftitle,vs_sid1,vs_fid,c_row.fid,'tsProcess','tkTask','temPreempt','tpmOpen','tesReady','尚未处理',vs_fdoctype,vs_fdoctypename,vs_sid4,'run',sys_guid(),
				   c_row.fsoper,c_row.fsoper,c_row.fsdate,'system','/ORG01.ogn/PSN01@ORG01.psm','/资阳市医保局/system','ORG01','资阳市医保局',
				   vs_sprocess,vs_sprocessname,'secretaryDealActivity','科室负责人签字','','/ED/doc/process/'||vs_scurl||'/checkActivity.w','/ED/doc/process/'||vs_seurl||'/secretaryDealActivity.w',
				   '0','system','system','',sysdate,''
				   );
				   dbms_output.put_line('vs_sid4:'||vs_sid4||'  --  '||'sdata1:'||vs_fid);
				   --更改提取状态
				   update oaedi.audit_master am set am.fstat='03',am.froper_app='system',am.frdate_app=sysdate where  am.fid=c_row.fid;
			   end loop;
		  end;
		  --select am.fid into vs_fid from oaedi.audit_master am;
		end createAuditData;



<=====================================================================================================================================================================>
<=====================================================================================================================================================================>
这是达梦数据库的,但由于达梦数据库与oracle数据库的语法很相近,所有就把它放在这儿

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何创建 自定义类 

	CREATE  OR REPLACE  TYPE type_row AS OBJECT(
	 whaq  INT ,
	 js  INT ,
	 line  INT );
	 
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何创建函数(一) 这里这个函数被 select_xqqk_by_dqxq_all_systhetical 函数调用

	create or replace function select_xqqk_by_dqxq_systhetical(
	prison_id_in varchar,--所属监狱编号
	rjsj_start_in date, --开始入监时间
	rjsj_end_in date, --结束入监时间
	xq_in varchar,xqn_start_in number,xqn_end_in number,line_in number,
	classify_type_in varchar2 -- 套表类型
	)  
	return type_table pipelined as   v type_row;  
	begin  	
	  if 'ChartsAnalysis_wcnf' = classify_type_in then -- 在押未成年犯构成情况调查表
		for myrow in (  -- 这个myrow是一个自定义的类
				select t.zm as whaq,count(t.dqxxid)as js from (
					select t.id as dqxxid ,t.rjsj, t.ypxz,
					case when  t.ysyxxq like '%死%'  or t.ysyxxq like '%期%' then ''
					else t.ysyxxq end as ypxq,  to_number(REGEXP_SUBSTR(t.ysyxxq,'[^年]+',1,1,'i'))  as dqxqn,
					case when t3.zzm like '%危害%安全%' then '1' else '0' end as zm from bs_bsinfo t
					left join bs_dqxx t3 on t3.zfid = t.id
					left join bs_zfsyqk z on t.id=z.zfid 
					where z.wcnfz = 1 and instr(prison_id_in,','|| t3.prison_id||',')>0
					) t
					where  t.ypxz=xq_in  and  t.dqxqn>=xqn_start_in*365 and  t.dqxqn<xqn_end_in*365 and t.rjsj>=rjsj_start_in and t.rjsj<=rjsj_end_in
					group by t.zm
		   ) loop 
		  v := type_row(myrow.whaq, myrow.js,line_in);  
		  pipe row (v);  
		end loop;  
	  elseif 'ChartsAnalysis_wjf' = classify_type_in then -- 在押外国籍犯构成情况调查表
		for myrow in (
				select t.zm as whaq,count(t.dqxxid)as js from (
					select t.id as dqxxid ,t.rjsj, t.ypxz,
					case when  t.ysyxxq like '%死%'  or t.ysyxxq like '%期%' then ''
					else t.ysyxxq end as ypxq,  to_number(REGEXP_SUBSTR(t.ysyxxq,'[^年]+',1,1,'i'))  as dqxqn,
					case when t3.zzm like '%危害%安全%' then '1' else '0' end as zm from bs_bsinfo t
					left join bs_dqxx t3 on t3.zfid = t.id 
					left join bs_wjxx w on (t.id = w.zfid) 
					where w.gj != '中国' and instr(prison_id_in,','|| t3.prison_id||',')>0
					) t
					where  t.ypxz=xq_in  and  t.dqxqn>=xqn_start_in*365 and  t.dqxqn<xqn_end_in*365 and t.rjsj>=rjsj_start_in and t.rjsj<=rjsj_end_in
					group by t.zm
		   ) loop 
		  v := type_row(myrow.whaq, myrow.js,line_in);  
		  pipe row (v);  
		end loop;  
	  else
		for myrow in (
				select t.zm as whaq,count(t.dqxxid)as js from (
					select t.id as dqxxid ,t.rjsj, t.ypxz,
					case when  t.ysyxxq like '%死%'  or t.ysyxxq like '%期%' then ''
					else t.ysyxxq end as ypxq,  to_number(REGEXP_SUBSTR(t.ysyxxq,'[^年]+',1,1,'i'))  as dqxqn,
					case when t3.zzm like '%危害%安全%' then '1' else '0' end as zm from bs_bsinfo t
					left join bs_dqxx t3 on t3.zfid = t.id 
					where instr(prison_id_in,','|| t3.prison_id||',')>0
					) t
					where  t.ypxz=xq_in  and  t.dqxqn>=xqn_start_in*365 and  t.dqxqn<xqn_end_in*365 and t.rjsj>=rjsj_start_in and t.rjsj<=rjsj_end_in
					group by t.zm
		   ) loop 
		  v := type_row(myrow.whaq, myrow.js,line_in);  -- 这个type_row是一个自定义的类
		  pipe row (v);  
		end loop;  
	  end if;

	return;  
	end select_xqqk_by_dqxq_systhetical;

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何创建函数(一) 这要用到另外一个自定义的函数

create or replace function select_xqqk_by_dqxq_all_systhetical(
prison_id_in varchar,--所属监狱编号
rjsj_start_in date, --开始入监时间
rjsj_end_in date, --结束入监时间
classify_type_in varchar2 -- 套表类型
)  
return type_table pipelined as   v type_row;  -- 这个type_table是一个自定义的类
begin  		
   for myrow in (
		--下面的  select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',0,1,11,classify_type_in)) 这条
		--语句是调用了select_xqqk_by_dqxq_systhetical 这个函数
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',0,1,11,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',1,3,12,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',3,5,13,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',5,7,14,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',7,10,15,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',10,15,16,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'有期徒刑',15,100,17,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_sx_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'无期徒刑',18,classify_type_in))
   		union all 
   		select whaq,js,line from table (select_xqqk_by_dqxq_sx_systhetical(prison_id_in, rjsj_start_in, rjsj_end_in,'死缓',19,classify_type_in))
   		
   ) loop  
  v := type_row(myrow.whaq, myrow.js, myrow.line);  -- 这个type_row是一个自定义的类
  pipe row (v);  
end loop;  
return;  
end select_xqqk_by_dqxq_all_systhetical;

......................................上面的部分是达梦数据库语句,oracle 时 只能参考,不能直接使用...........................................................

<=====================================================================================================================================================================>
<=====================================================================================================================================================================>
两道经典的数据库题 (涉及 group by ,order by , 子查询, where 等)

	学生成绩表
	
	姓名 : name 	课程 : subject 		分数 : score 		学号 : stuid
	
	张三			数学				89					1
	张三			语文				80					1
	张三			英语				70					1
	李四			数学				90					2
	李四			语文				70					2
	李四			英语				80 					2
	
	>> 1. 计算每个人的总成绩并排名(要求显示字段: 姓名,总成绩)
	
	select name , sum(score) from stuscore group by name order by sum(score) asc
	
	>> 2. 计算每个人的单科最高成绩(要求显示字段: 学号,姓名,课程,最高成绩)

	select a.stuid,a.name,a.subject,a.score 
	from stuscore a,(select name, max(b.score) s from stuscore b group by name) c
	where a.score = c.s
	
<=====================================================================================================================================================================>
oracle的查询sql中如果where条件后面包含了有参数的函数,那么在进行分页查询是可能查不出数据

	1.例如下面这种情况
	
		SELECT b.* FROM (SELECT rownum r_00_ ,a.* FROM ( 
		select  baseInfo.bh  ,baseInfo.xm  from criminal_base_info baseInfo    
		where 1=1 and   (get_zxxq(baseInfo.id,sysdate)) between '010000' and '020000'    
		order by baseInfo.bh asc ) a ) b 
		where  1=1 and b.r_00_ >= 1 and b.r_00_ <= 20
		
	2.解决办法
	
		将这个函数的参数放到查询列中即可 baseInfo.id
		
		SELECT b.* FROM (SELECT rownum r_00_ ,a.* FROM ( 
		select  baseInfo.id id_00_ ,baseInfo.bh  ,baseInfo.xm  from criminal_base_info baseInfo    
		where 1=1 and   (get_zxxq(baseInfo.id,sysdate)) between '010000' and '020000'    
		order by baseInfo.bh asc ) a ) b 
		where  1=1 and b.r_00_ >= 1 and b.r_00_ <= 20

<=====================================================================================================================================================================>






























<=====================================================================================================================================================================>
<=====================================================================================================================================================================>
									数据库复习

<=====================================================================================================================================================================>
rowid与rownum:

	rowid:是一个伪列,表示一条记录放在磁盘中什么的位置
	rownum :是一个伪列,主要是用来做分页的,生成连续的列

	SELECT rownum ,e.* from emp e

	rownum 的取值永远是从一开始的

	对于SELECT e.* FROM emp e ORDER BY e.sal desc 语句,它是先列出rownum号后再排序的 .

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
数据库的逻辑结构:

	tablespace ---> segment ---> extents ---> block

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
视图:
	
	视图一般分为一般视图与 物化视图

	物化视图: 主要使用来提高性能的,并且可以查询重写.

	查询重写: 如果人为手写的sql语句的效率不高,oracle会自动重写

	物化视图的刷新: 有 全量 和 增量 

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
修改一般视图:
		
	修改一般视图上的信息会影响原表的数据 ,所有我们在使用一般视图时都加上 read only

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
物化视图和一般视图的相互关系:

	一般用到了物化视图就会用到查询重写,用到查询重写就会用到物化视图

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何创建物化视图:

	create or replace materialized view 物化视图名

	as
 
	select * from 表名

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle 记录被另一个用户锁住

	今天在oracle数据中删除数据时提示“记录被另一个用户锁住” 解决方法： 
	1、查看数据库锁,诊断锁的来源及类型： 
	　　select object_id,session_id,locked_mode from v$locked_object; 
	或者用以下命令： 
	select b.owner,b.object_name,l.session_id,l.locked_mode 
	from v$locked_object l, dba_objects b 
	where b.object_id=l.object_id 

	2、找出数据库的serial#,以备杀死： 
	　　 select t2.username,t2.sid,t2.serial#,t2.logon_time 
	from v$locked_object t1,v$session t2 
	where t1.session_id=t2.sid order by t2.logon_time; 

	3、杀死该session 
	　　alter system kill session 'sid,serial#'

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于oracle数据库与mysql数据库的日期类型:

	mysql中timestamp类型对应oracle数据库中的date类型

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
KSQL如何使用关键字fid

	update OA_AM_Archival t set t.fState = '03' where t.fid = :fid and t.fState = '04'
	把t.fid换成t ，然后到概念中把fid这个关系删除了
	
	即把他改为如下
	
	update OA_AM_Archival t set t.fState = '03' where t= :fid and t.fState = '04'
	把t.fid换成t ，然后到概念中把fid这个关系删除了

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle从创建表空间到创建用户再到对这个用户进行授权的操作:

	-----创建表空间
		create tablespace jbpm
			   logging
			   datafile 'D:\oracle\product\10.2.0\oradata\jbpm.ora' size 100M reuse
			   extent management local segment space management auto;
		-----创建用户
		create user jbpmuser
			   identified by "jbpmuser"
			   default tablespace jbpm
			   temporary tablespace temp
			   profile default
			   quota unlimited on jbpm;
		--授权
		grant connect to jbpmuser;
		grant exp_full_database to jbpmuser;
		grant imp_full_database to jbpmuser;
		grant connect,resource,dba to jbpmuser;

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle表空间名字的后缀 :.ora和.dbf有什么不同？

	没什么区别，Oracle的较早版本好像是.dbf，现在好像都是.ora；这只是一个名字而已，只要文件格式符合Oracle的要求就OK了

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
电子档案系统中创建表空间及用户的案例:

	create tablespace OASYS datafile 'D:\app\Administrator\oradata\orcl\OASYS.dbf' size 100M autoextend on;
	drop user OASYS cascade;
	create user OASYS identified by OASYS default tablespace OASYS;
	grant connect,resource,dba to OASYS;
	
	.........................................................................................................................(这windows系统)

	create tablespace OAAPP datafile 'D:\app\Administrator\oradata\orcl\OAAPP.dbf' size 100M autoextend on;
	drop user OAAPP cascade;
	create user OAAPP identified by OAAPP default tablespace OAAPP;
	grant connect,resource,dba to OAAPP;
	
	.........................................................................................................................(这是针对linux系统 : /u01 其实就相当于是跟路径)
	
	create tablespace OASYS datafile '/u01/app/oracle/oradata/oa5120/OASYS.dbf' size 100M autoextend on;
	drop user OASYS cascade;
	create user OASYS identified by OASYS default tablespace OASYS;
	grant connect,resource,dba to OASYS;
		
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
ORA-01940无法删除当前已连接用户

		最近Oracle把哦整爽老。哇哈哈。。

		1)查看用户的连接状况
		select username,sid,serial# from v$session

		......................................................................................................................................

		如下结果：

		username          sid                serial#

		......................................................................................................................................

		NETBNEW          513              22974
		NETBNEW          514              18183
		NETBNEW          516              21573
		NETBNEW          531              9
		WUZHQ             532              4562

		(2)找到要删除用户的sid,和serial，并删除

		......................................................................................................................................

		如：你要删除用户'WUZHQ',可以这样做：

		alter system kill session'532,4562'

		(3)删除用户

		......................................................................................................................................

		drop user username cascade

		(**)如果在drop 后还提示ORA-01940:无法删除当前已链接的用户，说明还有连接的session，可以通过查看session的状态来确定该session是否被kill 了，用如下语句查看：

		......................................................................................................................................

		select saddr,sid,serial#,paddr,username,status from v$session where username is not null

		结果如下(以我的库为例)：

		 saddr                     sid           serial#            paddr              username              status

		......................................................................................................................................

		564A1E28              513           22974            569638F4        NETBNEW             ACTIVE
		564A30DC              514          18183            569688CC        NETBNEW            INACTIVE
		564A5644              516           21573            56963340        NETBNEW            INACTIVE
		564B6ED0              531           9                   56962D8C        NETBNEW            INACTIVE
		564B8184              532          4562               56A1075C        WUZHQ                KILLED

		 

		status 为要删除用户的session状态，如果还为inactive，说明没有被kill掉，如果状态为killed，说明已kill。

		由此可见，WUZHQ这个用户的session已经被杀死。此时可以安全删除用户。	

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查看他当初被创建时表空间的SQL语句呢(查看表空间)?

	select dbms_metadata.get_ddl('TABLESPACE','NEWYZ2') from dual;  //TABLESPACE : 是固定值 , NEWYZ2 : 指的表空间的名字

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
删除表空间：
	可以先将其offline
	alter tablespace xx offline;
	将磁盘上的数据文件一同删除
	drop tablespace xxx including contents and datafiles;

	删除用户：
	drop user xxx;
	如果用户的schema中有objects ，需要加cascade参数，即drop user xxx cascade;
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
表空间自动扩展功

	--开启表空间自动扩展功能语法：
	alter database datafile '对应的数据文件路径信息' autoextend on next 100m maxsize 10000m;
	--关闭表空间自动扩展功能语法：
	alter database datafile '对应的数据文件路径信息' autoextend off;
	--查看表空间是否自动扩展
	select tablespace_name,file_name,autoextensible from dba_data_files where tablespace_name = 'SEC_D';

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
IMP-00010：不是有效的导出文件，头部验证失败 

	oracle 导入dmp 报 IMP-00010：不是有效的导出文件，头部验证失败
	这是由于导出的dmp文件与导入的数据库的版本不同造成的
	用Notepad++查看了dmp文件，在头部具修改成你将导入目标数据库的版本号
	以下对应的版本号：
	　　11g R2：V11.02.00
	　　11g R1：V11.01.00
	　　10g：V10.02.01
	　　
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle中的exp与imp的使用案例:

	导出: C:\Users\Administrator> exp OADOC/OADOC@X501 grants=yes compress=no file=oadoc //此处的后缀名不写默认为dmp
	
	导入 C:\Users\Administrator> imp OADOC/OADOC@ORCL grants=yes file=D:\log\data\temp\oadoc.DMP full=y
	
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
oracle中使用exp与imp来导出与导入几张表的使用案例

	导出:(导出 base_column_extra,base_column_values,base_value_convert 这几张表)
		exp dangkasync_ql/123456789@bjhy49 file=d:\aaa.dmp tables=base_column_extra,base_column_values,base_value_convert log=d:xx.log

	导入:
		imp dangkasync_ql/123456789@bjhy49 file=d:\aaa.dmp full=y

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
imp-00015: 由于对象已存在, 下列语句失败:

	只需要在imp 命令之后加入参数，ignore=y 即可解决。 exp 导出多张表： exp 用户名/密码@实例名 tables="(table1,table2,……table n)" file=..... log=....... Linux下注意在括号上加双引号，有时不用添加。

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Oracle imp 关于fromuser 和 touser的用法

	fromuser就是把当前的dmp文件中的某一个用户下的数据取出。
	touser就是把现在dmp文件中的数据导入到目标库的指定user下。
	具体命令这样。
	exp userid=system/manager owner=username1 file=expfile.dmp 

	imp userid=system/manager fromuser=username1 touser=username2 ignore=y file=expfile.dmp 
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
imp/exp 导出导入一个用户下的数据
	1.导出:
		exp userid=system/admin123@orcl  owner=titan file=D:\jy.dmp
		
		备注: 导出 titan 用户的所有数据
	
	2.导入:
		imp userid=system/admin123@orcl touser=wulin fromuser=titan ignore=y file=D:\jy.dmp
		
		备注 : 这里是将 titan 用户的所有数据都导入到 wulin用户中, 注意,wulin 用户必须是一个空库,不然可能会出现错误
		
	注意:
		1.system/admin123@orcl 这里是数据库的管理员用户名与密码,如果数据库中有多个实例,还要指定数据库的实例 
		
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
imp/exp远程导出非本机的一个用户下的数据

	exp userid=system/admin123@10.2.120.11:1521/orcl  owner=yzpt file=D:\tmp\jy_5147.dmp
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Oracle中使用expdp/impdp 数据泵导出/导入 数据的步骤: 从11g到10g

	expdp导出(导出的是一个用户对象下的对象):

	第一步:登陆管理员用户
	
		1.sqlplus/nolog

		2.conn as sysdba
		
		3.输入用户名和密码
		
	第二步:创建输出目录
	
		1.create directory oaedi_dir as 'D:\export\oaedi'  //创建输出目录
		
		2.select * from dba_directories; //查看已经创建的目录
		
		3.grant read,write on directory oaedi_dir to oaedi; //将该目录授权给某个用户(oaedi是一个用户)
		
		4.退出oracle数据库,回到cmd更目录
		
	第三步:
	
		sql> expdp oaedi/oaedi@orcl directory=oaedi_dir dumpfile=oaedi.dmp logfile=oaedi.log version=10.2.0.3.0 schemas=oaedi
		
		解析: 1.oaedi/oaedi@orcl 这是用户名与密码及sid实例
		
			  2.directory=oaedi_dir //这是刚刚建的输出目录
			  
			  3.dumpfile=oaedi.dmp //这是将要输出的数据文件
			  
			  4.logfile=oaedi.log  //这是将要输出的日志文件
			  
			  5.version=10.2.0.3.0 //这是将要导入的数据库版本号
			  
			  6.schemas=oaedi //将这个用户下的所有对象都导出来
			  
	....................................................................................................................................................
	
	impdp导入(导入的是一个用户对象下的对象):
	
	第一步:建立表空间及用户和授权:
	
		1. 	create tablespace OASYS datafile 'D:\app\Administrator\oradata\orcl\OASYS.dbf' size 100M autoextend on;
			drop user OASYS cascade;
			create user OASYS identified by OASYS default tablespace OASYS;
			grant connect,resource,dba to OASYS;
			
	第二步:登陆管理员用户
	
		1.sqlplus/nolog

		2.conn as sysdba
		
		3.输入用户名和密码
		
	第三步:创建输入目录
	
		1.create directory oaedi_dir as 'D:\export\oaedi'  //创建输入目录
		
		2.select * from dba_directories; //查看已经创建的目录
		
		3.grant read,write on directory oaedi_dir to oaedi; //将该目录授权给某个用户(oaedi是一个用户)
		
		4.退出oracle数据库,回到cmd更目录
		
	第四步:
	
		sql> impdp OAEDI/OAEDI@orcl directory=oaedi_dir dumpfile=oaedi.dmp logfile=oaeid.log version=10.2.0.3.0 schemas=OAEDI
		
		解析: 1.OAEDI/OAEDI@orcl 这是用户名与密码及sid实例
		
			  2.directory=oaedi_dir //这是刚刚建的输入目录
			  
			  3.dumpfile=oaedi.dmp //这是将要输入的数据文件
			  
			  4.logfile=oaedi.log  //这是将要输入的日志文件
			  
			  5.version=10.2.0.3.0 //这是将要导入的数据库版本号
			  
			  6.schemas=OAEDI //导入到这个用户对象下,注意最后没有分号";"
			  
	....................................................................................................................................................
	expdp导出导出表结构(导出的是一个用户对象下的对象):

		expdp oaedi/oaedi@orcl directory=oaedi_dir dumpfile=oaedi.dmp logfile=oaedi.log version=10.2.0.3.0 schemas=oaedi content=metadata_only
		
	....................................................................................................................................................
	expdp导入表结构(且是从一个用户到另一个用户):

		C:\Users\Administrator>impdp myoaedi/myoaedi@orcl directory=myoedi_dir dumpfile=myoaedi.dmp logfile=myoaedi.log version=
		10.2.0.3.0 remap_schema=oaedi:myoaedi
		

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------















<======================================================================================================================================================================>

																		oracle的学习笔记完整记录		

<======================================================================================================================================================================>
oracle管理工具的介绍(1)

	概述 : 是oracle自带的工具软件,主要用于执行sql语句,pl\sql块.
	
	如何使用:
	
		(1) 在开始 --> 所有程序 --> oracle ....... --> 打开 sql*plus 
		
		(2) 在运行栏中输入 : sqlplusw 即可
		
oracle管理工具的介绍(2)
		
	概述:sqlplus doc 下操作oracle的工具,其功能和sql*plus相似
	
		(1) 在运行栏中输入 sqlplus
		
		(2) 找到该可执行文件 sqlplus.ext,
		
		在oracle主目录 \oracle\product\10.2.0\db_1\bin\sqlplus.exe,鼠标双击即可
		
oracle管理工具的介绍(3)

		概述:oracle的企业管理器(oem oracle enterprise manager)
		
		位置在 开始 --> oracle ....... --> enterprise manager console 即可启动oracle的企业管理器,是一个图形界面环境.
		
oracle管理工具的介绍(4)

	概述:pl/sql developer 属于第三方软件,主要用于开发,测试,优化 oracle pl/sql 的存储过程比如 :触发器,此软件oracle不带,需要单独安装.
		
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------	oracle中显示当前用户的命令:

	show user;

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
sql*plus常用的命令:

	连接命令:
	
		(1) conn[ect] 
		
			用法:conn 用户名/密码@网络服务名 [as sysdba/sysoper] ,当用特权用户身份连接时,必须带上 as sysdba 或是 as sysoper 
			
		(2) disc[onnect]
		
			说明:该命令用来断开与当前数据库的连接,
			
		(3) passw[ord]
		
			说明:该命令用于修改用户的密码.如果要修改其他用户的密码,需要用 sys/system登陆.
			
		(4) show user
		
			说明: 显示当前用户名
			
		(5) exit
		
			说明: 该命令会断开与数据库的连接,同时会退出sql*plus
			
	..................................................................................................................................................................		
	文件操作命令
	
		(1)start和@
		
			说明: 运行sql脚本
			
			案例: sql>@ d:\a.sql 或者 sql> start D:\a.sql
			
		(2)edit
		
			说明:该命令可以编辑指定的sql脚本
			
			案例: sql>edit d:\a.sql
			
		(3)spool
		
			说明: 该命令可以将sql*plus屏幕上的内容输出到指定文件中去.
			
			案例: sql>spool d:\b.sql 并输入 sql>spool off
			
	.....................................................................................................................................................................
	
	交互式命令
	
		(1)&
		
			说明:可以替代变量,而该变量在执行时,需要用户输入.
			
			sql> select * from emp where job = '&job';
			
		(2)edit:
		
			说明:该命令可以编辑指定的sql脚本
			
			案例: sql>edit d:\a.sql
			
		(3)spool
		
			说明:该命令可以将sql*plus屏幕的内容输出到指定文件中去.
			
			案例: sql> spool d:\b.sql 并输入 sql>spool off


	.....................................................................................................................................................................
	显示和设置环境变量
	
		概述: 可以用来控制输出的各种格式,set show 如果希望永久的保存相关的设置,可以去修改 glogin.sql脚本
		
		(1)linesize
		
			说明:设置显示行的宽度,默认是80个字符
			
			sql>show linesize
			
			sql>set linesize 90
			
		(2)pagesize
		
			说明:设置每页显示的行数目,默认是14
			
			用法和linesize一样
			
		至于其他环节参数的使用也是大同小异
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
创建用户:

	概述: 在oracle中要创建一个新的用户使用 create user 语句,一般是具有dba(数据库管理员)的权限才能使用.
	
	例如: create user 用户名 identified by 密码 ;
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
给用户修改密码:

	概述: 如果给自己修改密码可以直接使用 sql>password 用户名
	
	如果给别人修改密码则需要具有dba的权限,或拥有alter user的系统权限
	
	sql>alter user 用户名 identified by 新密码
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle 察看用户是否被锁，解锁以及改密码

	以管理员身份登陆

	察看用户状态（是否被锁）

	select * from dba_users where username='user1'

	解锁

	ALTER USER user1 ACCOUNT UNLOCK;

	修改用户密码

	alter user user1 identified by newpass;

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
删除用户:

	概述: 一般以dba的身份去删除某个用户,如果用其他用户去删除用户则需要具有 drop user的权限,比如 drop user 用户名 [cascade]
	
	注意: 在删除用户时,如果要删除的用户,已经创建了表,那么就需要 在删除时 带一个参数 cascade ;
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle安装成功后,会默认生成三个用

	sys 用户 : 超级管理员 权限最高 它的角色 dba 密码 change_on_install 
	
	system 用户:是系统管理用 权限也很高,他的角色是 dbaoper 密码 manager 
	
	scott 用户 : 普通用户 密码是: tiger 
	
	sys 与 system 相比: sys有 create database 的权限,而system没有,其他相似.
	
	其实在日常对oracle管理过程中,使用system就够了.

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
用户管理的综合案例:

	概述: 创建的新用户是没有任何权限的,甚至连登陆的数据库的权限都没有,需要为其指定相应的权限.给一个用户赋权限使用命令grant,回收权限使用命令 revoke .
	
	为了给讲清楚用户的管理,这里我给大家举一个案例:

	create user xiaoming identified by m123 ;

	希望xiaoming用户可以去查询emp表
	希望xiaoming用户可以去查询scott的emp表
	
	grant select on emp to xiaoming 
	
	希望 xiaoming 用户可以去修改 scott的emp表
	
	grant update on emp to xiaoming 
	
	希望 xiaoming 用户可以去修改/删除,查询,添加 scott的emp表
	
	grant all on emp to xiaoming ;

	scott 希望收回 xiaoming 对 emp 表的查询权限.
	
	revoke select on emp from xiaoming ;

	//对权限的维护:
	希望xiaoming用户可以去查scott的emp表/还希望小明可以把这个权限继续给别人.
	
	如果是对象权限,就加入 with grant option
	
	grant select on emp to xiaoming with grant option ;
	
	如果是系统权限,

	system给xiaoming权限时:
	
	grant connect to xiaoming with admin option
	
	问题 : 如果scott把xiaoming 对emp表的查询权限回收,那么xiaohong会这样?
	
	答案: 被回收
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
oracle用户的管理

	概述:profile是口令限制,资源限制的命令集合,当建立数据库时,oracle会自动建立名称为default的profile.当建立用户没有指定profile选项,那么oracle就会将default分配给用户.
	
	  (1) 账户锁定
	  
		概述: 指定该账户(用户)登陆时最多可以输入密码的次数,也可以指定用户锁定的时间(天)一般用dba的身份去执行该命名
		
			例子: 指定tea这用户最多只能尝试3次登陆,锁定时间为2天,让我们看看这么实现.
			
			创建profile文件:
			
			sql>create profile lock_account limit failed_login_attempts 3 password_lock_time 2 ;
			
			sql>alter user tea profile lock_account;

		(2)给账户(用户)解锁
		
		sql>alter user tea account unlock ;
		
		(3)终止口令
		
		为了让用户定期修改密码可以使用终止口令的指令来完成,同样这个命令也需要dba身份操作.
		
		例子:给前面创建的用户tea创建一个profile文件,要求该用户每隔10天要修改自家的登陆密码,宽限期为2天.看看怎么做.
		
		sql>create profile myprofile limit password_life_time 10 password_grace_time 2 ;
		
		sql>alter user tea profile myprofile

		(3)口令历史:
		
			概述:如果希望用户再修改密码时,不能使用过的密码,可使用口令历史,这样oracle就会将口令修改的信息存放到数据字典中,这样当用户修改密码时,oracle就会对新旧密码进行比较,当发现新旧密码一样时,就会提示用户重新输入密码.
			
			例子: (1) 建立profile
			
			sql>create profile password_history limit password_life_time 10 password_grace_time 2 password_reuse_time 10
			
			password_reuse_time //指定口令可重用时间及10天后就可以重用
			
			(2)分配给某个用户:
			
			
			(3)删除profile
			
			概述:当不要某个profile文件时,可以删除该文件.
			
			sql> drop profile password_history [cascade]
			
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------	oracle 表的管理 

	表名和列的命名规则:
	
		(1) 必须以字母开头
		
		(2) 长度不能超过30字符
		
		(3) 不能使用oracle的保留字
		
		(4) 只能使用如下字符 A-Z,a-z,0-9,$,#等
			
	...............................................................................................................................................................
	字符型

		char : 定长 最大2000字符
		
			例子: char(10) '小韩' 前四个字符放 '小韩',后添6个空格补全
		
		varchar2(20) 变成 最大4000字符
		
			例子 : varchar(10) '小韩' oracle分配四个字符,这样可以节省空间
			
		clob(character large object) 字符型大对象,最大4G
		
	...............................................................................................................................................................
	数字型
	
		number 范围 10的-38次方,可以表示整数,可以表示小数.
		
		number(5,2) 表示一个小数有5位有效数,2位小数,范围 -999.99 -- +999.99
		
		number(5) 表示一个五位整数,范围 -99999 -- +99999
		
	...............................................................................................................................................................
	日期类型:
	
		date : 包含年月日和时分秒
		
		timestamp : 这是oracle9i 对date数据类型的扩展
		
	...............................................................................................................................................................
	二进制数据类型(图片类型)
	
		blob : 二进制数据,可以存放图片/声音 4g
		
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
oracle判断某字符串是否数字
		
	用正则表达式: ORACLE查出列为纯数字的值: 
	
	SELECT * FROM DUAL WHERE LENGTH('LSS12345') = LENGTH(REGEXP_REPLACE('LSS12345', '[^0-9]'))
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
将截取的数字 字符串彻底的转换数字的案例

	select to_number(REGEXP_REPLACE(to_number(nvl(substr('224234323',0,2),0)), '[^0-9]')) from dual; //将截取的字符串彻底的转换数字
		
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------	oracle表的管理 怎样创建表

	创建一个学生表
	
	sql>create table student( --表名
		xh number(4), --学号
		xm varchar2(20), --姓名
		sex char(2), --性别
		birthday date, --出生日期
		sal number(7,2) --奖学
	);
	
	...............................................................................................................................................................
	删除表:

		drop table student;
			
	...............................................................................................................................................................
	修改表
	
		添加一个字段: 
		
			sql>alter table student add (classid[字段名] number(2)[数据类型]);
		
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		修改字段的长度
		
			sql>alter table student modify (xm varchar2(20));

		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		修改字段的类型/或是名字(不能有数据)
		
			sql>alter table student modify (xm char(30));
			
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````	
		删除一个字段
		
			sql>alter table student drop column sal;
			
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		修改表的名字
		
			sql>rename student 同 stu;
			
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		删除表
			
				sql>drop table student;
				
				drop table core_accusation cascade constraints ; //级联删除表

		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		查看一张表的所有列的数据类型
		
			desc student[表名];

	...............................................................................................................................................................
	添加数据
	
		所有字段都插入
		
		insert into student values ('字段1的值',字段2的值,...,最后一个字段的值);
		
		insert into student values ('A001','张三','男','01-5月-05'[这是一个日期类型的值],10);
		
		说明:oracle 中默认的日期格式'DD-MON-YY' ,其中 dd 日子(天),mon 月份, yy 2位的年 '09-6月-99' 
		
		如果想要插入 1999年6月9号,则需要改日期的默认格式
		
		alter session set nls_date_format = 'yyyy-mm-dd';
		
		修改后,可以用我们熟悉的格式添加日期类型:
		
		insert into student values ('A001','张三','男','1905-05-05'[这是一个日期类型的值],10);

		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		插入部分字段
		
			insert into student(xh,xm,sex) values('A003','JOHN','女');
		
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		插入空值

			insert into student(xh,xm,sex,birthday) values('A004','MARTIN','男',null);

		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		要查询某一个字段是空,
		
			select * from student where birthday is null
		
		要查询某一个字段不是空,
		
		select * from student where birthday is not null

	...............................................................................................................................................................
	改一个字段:
	
		update student set sex='女' where xh ='A001';
		
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		修改多个字段
		
		update student set sex = '男' ,birthday = '1980-04-01' where xh = 'A001';
		
		``````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
		修改含有null值的数据
		
		update student set sex is null ,birthday = '1980-04-01' where xh = 'A001';
		
	...............................................................................................................................................................	
	删除数据
	
		delete from student;
		
		删除所有记录,表结构还在,写日志,可以恢复,速度慢,
		
			drop table student ;删除表的结构和数据;
			
			delete from student where xh = 'A001'; 删除一条记录
			
			truncate table student 删除表中所有记录,表结构还在,不写日志,无法找回删除的记录,速度快
			
	...............................................................................................................................................................
	插入保存点,利用保存点来回滚,有利于我在操作数据失误后回滚数据
	
		sql>savepoint a[回滚点的名称];
		
		rollback to a; --回滚到保存点
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------		



	
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			


















<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------

sqlServer 

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
sqlServer 中常用的函数及使用案例

	/*
	-----sqlserver的一些函数及语法
	
	convert(datetime,rjrq) : 将字符串转换为日期
	datediff(year,convert(datetime,rjrq) : 得到两个日期差

	LEFT(xq,2 ) : 截取字符串
	 exec global_search @key = '030600' : 查询所有表中字段有 '030600' 的表及字段名

	*/
	................................................................
	使用案例:
		
		select count(*) from da_jbxx where zybz=1 and db='1';

		select db from da_jbxx where zybz=1 ;


		select db,count(1) from da_jbxx where zybz=1 group by db;

		select count(1) from da_jbxx where zybz=1
		and datediff(year,convert(datetime,rjrq),convert(datetime,'20161008'))>=2 
		and datediff(year,convert(datetime,rjrq),convert(datetime,'20161008'))<4;


		select count(1) from da_jbxx where zybz=1 and convert(datetime,rjrq)>=convert(datetime,'20131211');

		select * from da_jbxx where bh = '5117131853';

		select count(1) as xq  from da_jbxx where LEFT(xq,2 )>=2 and LEFT(xq,2 )<4 and zybz=1;

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
sqlServer中是函数计算余刑,即两个日期的差值;

	CREATE     function dbo.get_syxq  --剩余刑期
	( 
		@xq varchar(8),     --刑期
		@xqzr varchar(8),	--刑期止日
		@jzsj varchar(8)   --截止日期
	)
	returns varchar(16)

	with encryption
	as
	begin
	declare @syxq varchar(8),
			@yy int,@y1 int,@y2 int,
			@mm int,@m1 int,@m2 int,@m1_sy int,
			@dd int,@d1 int,@d2 int
	if left(@xq,2)='99'
	  set @syxq=@xq  --无期/死缓
	else if isnumeric(@xq)=0 or isdate(@xqzr)=0 or isdate(@jzsj)=0
	  set @syxq=''  --数据有问题
	else if @xqzr<=@jzsj
	  set @syxq=''--已刑满  --wyq 2005.05.31 不返回000000而返回空
	else
	  begin
		set @y1=left(@xqzr,4)         --取止日“年”
		set @m1=substring(@xqzr,5,2)  --取止日“月”
		set @d1=substring(@xqzr,7,2)  --取止日“天”
		set @y2=left(@jzsj,4)         --取截止日“年”
		set @m2=substring(@jzsj,5,2)  --取截止日“月”
		set @d2=substring(@jzsj,7,2)  --取截止日“天”
		set @yy=@y1-@y2  --余刑“年”
		set @mm=@m1-@m2  --余刑“月”
		if  @d1<@d2
		  begin
			set @mm=@mm-1
			--求止日上个月的总天数
			set @m1_sy=@m1-1
			if @m1_sy=0
			  set @m1_sy=12
			if @m1_sy=2
			  --2月总天数
			  set @m1_sy=(case when year(@xqzr)%4=0 then 29 else 28 end)
			else
			  --其他月总天数
			  set @m1_sy=(case when @m1_sy in (2,4,6,9,11) then 30 else 31 end)
			set @d1=@d1+@m1_sy  --止日“天”＋止日上个月的总天数
		  end
		set @dd=@d1-@d2  --余刑“天”
		if  @mm<0
		  begin
			set @yy=@yy-1
			set @mm=@mm+12
		  end
		set @syxq=RIGHT(CAST(100+@yy as varchar(3)),2)+
				  RIGHT(CAST(100+@mm as varchar(3)),2)+
				  RIGHT(CAST(100+@dd as varchar(3)),2)
	  end

	return @syxq
	end

<----------------------------------------------------------------------------------------------------------------------------------------------------------------------
sqlServer从多条数据中取出第一条数据
	
	CREATE   function dbo.get_xqzr 
	(
		@bh varchar(12),  --罪犯编号
		@jzsj varchar(8) --截止日期
	)
	returns varchar(8)

	with encryption
	as
	begin
	  declare @xqzr varchar(8)
		if @jzsj=''
			select top 1 @xqzr=zr from xfzb where bh=@bh  order by pcrq desc
		else
			select top 1 @xqzr=zr from xfzb where bh=@bh and pcrq<=@jzsj order by pcrq desc
		if @xqzr is null set @xqzr=''
	  return @xqzr
	
<----------------------------------------------------------------------------------------------------------------------------------------------------------------------



















